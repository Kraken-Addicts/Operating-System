## 보충2__동기화 도구들

<br>

### 보충2.1 :fallen_leaf: 배경　`jehong`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

### 보충2.2 :fallen_leaf:  임계구역 문제　`taelee`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

### 보충2.3 :fallen_leaf:  Peterson의 해결안 `yeosong`

문제

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


피터슨의 해결법은 원하는지 표시하는 flag와 차례인지 표시하는 turn을 동시에 써서 1 상호배제 2 진행 3 유한대기의 조건을 모두 만족시킨다.
하지만 다중스레드가 데이터를 공유하는 과정에서 순서를 신경을 안써버린다. 그래서 이 해결법도 무결성 문제가 있다.

</div>
</details>
<br><br>



### 보충2.4 :fallen_leaf:  뮤텍스  `kukim`

1. Mutex lock는 특정 코드 영역의 쓰레드를 실행할 때 한번에 하나 이상의 쓰레드만 실행 가능하도록 하는 방법이다. (O / X)

2. 아래의 코드 결과는 서술하시오.

```c
#exam2.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원, 1증가.
        sleep(1);
    }
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

# compile
# gcc exam2.c -o exam2
```


3. 아래의 코드 결과를 서술하시오

```c
#exam3.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
// 뮤텍스 객체 선언
pthread_mutex_t mutex_lock;
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    
    
 
    pthread_mutex_lock(&mutex_lock);
 
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원
        sleep(1);
    }
 
    pthread_mutex_unlock(&mutex_lock);
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
    // 뮤텍스 객체 초기화, 기본 특성으로 초기화 했음
    pthread_mutex_init(&mutex_lock, NULL);
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

# compile
gcc exam3.c -o exam3 -lpthread
```

Mutex 코드 참고(문제 다 풀고 들어가세요)
https://bitsoul.tistory.com/172

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


1. Mutex lock는 특정 코드 영역의 쓰레드를 실행할 때 한번에 하나 이상의 쓰레드만 실행 가능하도록 하는 방법이다. (O / X)
  - 정답 : X , 한번에 하나의 쓰레드만 실행 가능하도록 하는 방법이다.

2. 아래의 코드 결과는 서술하시오.

```c
#exam2.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원, 1증가.
        sleep(1);
    }
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

# compile
# gcc exam2.c -o exam2
```
- 정답 : Thread1, 2 모두 g_count 쓰레드 자원을 공유하기 때문에 매번 exam2를 실행할 때 마다 이상한 값이 나온다.


3. 아래의 코드 결과를 서술하시오

```c
#exam3.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
// 뮤텍스 객체 선언
pthread_mutex_t mutex_lock;
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    
    
 
    pthread_mutex_lock(&mutex_lock);
 
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원
        sleep(1);
    }
 
    pthread_mutex_unlock(&mutex_lock);
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
    // 뮤텍스 객체 초기화, 기본 특성으로 초기화 했음
    pthread_mutex_init(&mutex_lock, NULL);
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

# compile
gcc exam3.c -o exam3 -lpthread
```
- 정답 : Mutex Lock이 걸려서 Thread1이 먼저 실행된다면 Thread2는 1이 끝날 때 까지 임계영역에 들어가 수 없기 때문에 count 0 1 2를 출력하고 그 다음 Thread2의 count가 0 1 2 를 출력한다. 만약 Thread2가 먼저 실행된다면 앞에 설명한 것과 반대로 출력된다.

Mutex 코드 참고
https://bitsoul.tistory.com/172
</div>
</details>
<br><br>

### 보충2.5 :fallen_leaf:  세마포  `mihykim`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

### 보충2.6 :fallen_leaf:  모니터  `daelee`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

