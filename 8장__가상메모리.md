
## 8장 가상메모리

<br>

### 8-1 :fallen_leaf: 요구 페이징　`hylee`
 
**문제1. 요구페이징은 여행 갔을 때로 비유하면 a) 경우와 b) 경우 중 어떤 것일까요?**

(이때 냉장고 = 물리적 메모리,식재료 = 프로세스를 구성하는 페이지를 의미한다.)

a) 2박 3일간 필요한 모든 식재료를 한 번에 구입해서 냉장고에 넣는 것이다. 

b) 매 끼니마다 필요한 분량만큼 재료를 구입해서 냉장고에 보관하는 것이다.


<br>

**문제2. 물리적 메모리의 용량 제약과 관련된 요구 페이징의 주된 효용과 그렇게 할 수 있는 이유를 설명해주세요.**

<br>

**문제3. 요구 페이징 기법의 성능에 제일 영향을 끼치는 것은 무엇인가요? 그리고 그 이유도 설명해주세요.**



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
 **문제1. 요구페이징은 여행 갔을 때로 비유하면 a) 경우와 b) 경우 중 어떤 것일까요?**

(이때 냉장고 = 물리적 메모리,식재료 = 프로세스를 구성하는 페이지를 의미한다.)

a) 2박 3일간 필요한 모든 식재료를 한 번에 구입해서 냉장고에 넣는 것이다. 

b) 매 끼니마다 필요한 분량만큼 재료를 구입해서 냉장고에 보관하는 것이다.

> 정답 b

요구 페이징 기법에서는 당장 실행에 필요한 페이지만을 메모리에 적재해서 사용한다.



<br>

**문제2. 물리적 메모리의 용량 제약과 관련된 요구 페이징의 주된 효용과 그렇게 할 수  이유를 설명해주세요.**

> 정답 : 주된 효용은 프로그램이 물리적 메모리의 용량 제약을 벗어날 수 있도록 해주는 것이다.

> 이유 : 프로그램을 구성하는 페이지 중 일부만을 메모리에 적재하게 되므로 물리적 메모리의 용량보다 큰 프로그램도 실행할 수 있게 된다.

<br>

**문제3. 요구 페이징 기법의 성능에 제일 영향을 끼치는 것은 무엇인가요? 그리고 그 이유도 설명해주세요.**

> 정답 : 페이지 부재의 발생 빈도

> 이유 : 페이지 부재가 일어나면 요청된 페이지를 디스크로부터 메모리로 읽어오는 막대한 오버헤드가 발생하기 때문이다.

이때 발생하는 오버헤드 4가지

1. 페이지 부재 발생처리 오버헤드

2. 메모리에 빈 프레임이 없는 경우 스왑 아웃 오버헤드 

3. 요청된 페이지의 스왑 인 오버헤드 

4. 프로세스의 재시작 오버헤드

</div>
</details>
<br><br>

### 8-2 :fallen_leaf: 페이지 교체	　`yeha`
 
1. 페이지 교체(page replacement)는 무엇인가요?  

> 

2. 교체 알고리즘(replacement algorithm)은 무엇인가요?  

>

3(1). 페이지 폴트(page fault)가 나지 않는 교체 알고리즘이 존재한다. (O/X)  

3(2). 가장 페이지 폴트가 적게 발생하는 교체 알고리즘은 최적 페이지 교체 알고리즘이다. (O/X)    

3(3).모든 교체 알고리즘은 물리적 메모리 공간이 늘어나면 성능이 향상된다. (O/X)  

3(4).LRU (Least Recently Used) 알고리즘에서 페이지의 참조 횟수는 교체에 영향을 끼치지 않는다. (O/X)  

3(5). 대부분의 시스템에서 페이지 교체 알고리즘으로 클럭 알고리즘(clock algorithm)을 사용한다. (O/X)   

4. 최적 페이지 교체 알고리즘을 사용할 때, (가)에 들어갈 페이지는 무엇일까요?  

<a href="https://ibb.co/KKFcjGQ"><img src="https://i.ibb.co/bbzjg3y/1.png" alt="1" border="0"></a>

5. FIFO 알고리즘을 사용할 때, (가),(나),(다)에 들어갈 페이지는 무엇일까요?  
<a href="https://ibb.co/BzRV9qN"><img src="https://i.ibb.co/Wx1WLgt/2.png" alt="2" border="0"></a>


6. LRU 알고리즘은 어떤 페이지를 교체할까요?  

7. LFU 알고리즘은 어떤 페이지를 교체할까요?  
<a href="https://ibb.co/rM6FfYt"><img src="https://i.ibb.co/2PtWYx6/3.png" alt="3" border="0"></a>


8. 클럭 알고리즘이 동작하고 있습니다. (가), (나)에 들어갈 숫자는 무엇일까요?  
<a href="https://ibb.co/tP4CD2W"><img src="https://i.ibb.co/yBXsqkb/4.png" alt="4" border="0"></a>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
1. 페이지 교체(page replacement)는 무엇인가요?  

>메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아내 메모리에 빈 공간을 확보하는 작업  

2. 교체 알고리즘(replacement algorithm)은 무엇인가요?  

>페이지 교체를 할 때 어떤 프레임에 있는 페이지를 쫓아낼 것인지 결정하는 알고리즘  

3(1). 페이지 폴트(page fault)가 나지 않는 교체 알고리즘이 존재한다. (O/X)  

>페이지 폴트(page fault)가 나지 않는 교체 알고리즘이 존재한다. (X)  ⇒ 처음 참조될 때 페이지 폴트가 항상 발생된다.  

3(2). 가장 페이지 폴트가 적게 발생하는 교체 알고리즘은 최적 페이지 교체 알고리즘이다. (O/X)  

>가장 페이지 폴트가 적게 발생하는 교체 알고리즘은 최적 페이지 교체 알고리즘이다. (O)  => 최적 페이지 교체 알고리즘은 미래에 어떤 페이지가 어떤 순서로 참조될지 알고 있다는 전제하에 알고리즘을 운영한다. (실제 시스템에서 온라인으로 사용할 수 없다. 오프라인 알고리즘이라고 부른다.) 가장 적은 페이지 부재율을 보장하므로 다른 알고리즘의 성능에 대한 상한선을 제공한다. 따라서 어떤 시스템에서 새로운 교체 알고리즘을 설계했는데 그 성능이 빌레디의 최적 알고리즘과 유사하다면 더 이상 그 시스템을 위한 교체 알고리즘의 연구가 필요하지 않음을 뜻한다.  

3(3).모든 교체 알고리즘은 물리적 메모리 공간이 늘어나면 성능이 향상된다. (O/X)  

>모든 교체 알고리즘은 물리적 메모리 공간이 늘어나면 성능이 향상된다. (X)  => FIFO알고리즘은 메모리가 증가해도 페이지 폴트가 늘어나 성능이 더 나빠진다. (FIFO의 이상현상 FIFO anomaly)  

3(4).LRU (Least Recently Used) 알고리즘에서 페이지의 참조 횟수는 교체에 영향을 끼치지 않는다. (O/X)  

>LRU (Least Recently Used) 알고리즘에서 페이지의 참조 횟수는 교체에 영향을 끼치지 않는다. (O)  => 마지막으로 참조한 시점이 가장 오래 된 페이지를 교체한다. LFU (Least Frequently Used) 알고리즘은 페이지의 참조 횟수로 교체시킬 페이지를 결정한다.  

3(5). 대부분의 시스템에서 페이지 교체 알고리즘으로 클럭 알고리즘(clock algorithm)을 사용한다. (O/X)   

>대부분의 시스템에서 페이지 교체 알고리즘으로 클럭 알고리즘(clock algorithm)을 사용한다. (O)    => 프로세스 A가 CPU를 가지고 있으면서 주소 변환 시도를 한다고 할 때, 요청한 메모리가 물리적 메모리에 없으면 (페이지 폴트) 스왑 영역에서 가져온다. 이 때 디스크 접근을 필요로 하기 때문에 CPU제어권이 OS로 넘어간다. OS는 디스크에 있던 메모리가 올라온 시간은 알 수 있다. 하지만 어떤 페이지가 메모리에 있는데 다시 참조되는 상황 (가장 오래 전 참조된 페이지를 쫓아내야 하는데(LRU) 어떤 페이지가 가장 오래 전에 참조됐는지, 가장 참조 횟수가 적은 페이지를 쫓아내야 하는데 (LFU) 어떤 페이지가 가장 참조 횟수가 적은지 등등) 은 OS는 알 수가 없다. 이러한 이유로 LRU 알고리즘이나 LFU 알고리즘은 가상 메모리에서 사용할 수 없고, 버퍼 캐싱과 웹 캐싱에선 사용된다. (강의에서 뒷부분에 나온다고 합니다)  

4. 최적 페이지 교체 알고리즘을 사용할 때, (가)에 들어갈 페이지는 무엇일까요?   
<a href="https://ibb.co/KKFcjGQ"><img src="https://i.ibb.co/bbzjg3y/1.png" alt="1" border="0"></a>

>5

5. FIFO 알고리즘을 사용할 때, (가),(나),(다)에 들어갈 페이지는 무엇일까요?    
<a href="https://ibb.co/BzRV9qN"><img src="https://i.ibb.co/Wx1WLgt/2.png" alt="2" border="0"></a>

>4,1,2

6. LRU 알고리즘은 어떤 페이지를 교체할까요?  

>1

7. LFU 알고리즘은 어떤 페이지를 교체할까요?  

>4

<a href="https://ibb.co/rM6FfYt"><img src="https://i.ibb.co/2PtWYx6/3.png" alt="3" border="0"></a>

8. 클럭 알고리즘이 동작하고 있습니다. (가), (나)에 들어갈 숫자는 무엇일까요?  

<a href="https://ibb.co/tP4CD2W"><img src="https://i.ibb.co/yBXsqkb/4.png" alt="4" border="0"></a>

>0,0

⇒ reference bit이 1이다 → 0으로 바꾸고 다음 것 확인 → 1 이면 0 으로 바꿈 → 0 이면 교체  

reference bit = 1 → 시계바늘이 한 바퀴 도는 동안 이 페이지 참조가 한번은 있었다

reference bit = 0 → 시계바늘이 한 바퀴 도는 동안 이 페이지 참조가 없었다

</div>
</details>
<br><br>



### 8-3 :fallen_leaf: 페이지 프레임의 할당	　`mihykim`
#### 문제1
__(단답식) 다음 "할당 알고리즘(allocation algorithm)" 3가지 설명을 읽고 그림 중 (a)~(c)에 들어갈 적절한 알고리즘을 골라주세요__
```
● 균등할당 (equal allocation)
    - 모든 프로세스에게 페이지 프레임을 균일하게 할당함
● 비례할당 (proportional allocation)
    - 프로세스의 크기에 비례해 페이지 프레임을 할당함
● 우선순위 할당(priority allocation)
    - 프로세스 중 당장 CPU에서 실행될 프로세스와 그렇지 않은 프로세스를 구분하여 전자 쪽에 더 많은 페이지 프레임을 할당함
```

![image](https://user-images.githubusercontent.com/60066472/97395932-655ed780-1929-11eb-87b7-27cf19fb44ca.png)
![image](https://user-images.githubusercontent.com/60066472/97396453-76f4af00-192a-11eb-851e-81946be69e4a.png)

#### 문제2 
__(주관식) 마이스터고 2학년 재학 중인 '현준'이는 자신의 학습노트을 정리하던 중 잘못 기재된 문장을 발견했습니다. '현준'이를 도와 문장을 올바르게 고쳐주세요!__
- 2-1. 각 프로세스는 프로세스를 정상적으로 수행하기 위해서 `하나의 페이지 프레임만 할당받아도 괜찮다.`
  - 수정 : 
- 2-2. 반복문을 구성하는 페이지의 수보다 적은 양의 프레임을 할당한다면 `매 반복(iteration)마다 페이지 부재가 발생하는 것은 아니므로, 시스템의 성능에는 크게 영향이 없다.`
  - 수정 : 
- 2-3. 한 가지 프로세스에 대해 최소한으로 필요한 메모리의 양은 `현준이가 점심먹는 시간이거나 현준이가 꿈꾸는 시간이거나 항상 똑같다`
  - 수정 : 

<details>
 
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### 문제1
![image](https://user-images.githubusercontent.com/60066472/97396437-6c3a1a00-192a-11eb-8a66-1c439d917c41.png)

#### 문제2
- 2-1. 각 프로세스는 프로세스를 정상적으로 수행하기 위해서 `하나의 페이지 프레임만 할당받아도 괜찮다.`
  - 수정 : 각 프로세스는 프로세스를 정상적으로 수행하기 위해서 `적어도 일정 수준 이상의 페이지 프레임을 할당받아야 한다.`
- 2-2. 반복문을 구성하는 페이지의 수보다 적은 양의 프레임을 할당한다면 `매 반복(iteration)마다 페이지 부재가 발생하는 것은 아니므로, 시스템의 성능에는 크게 영향이 없다.`
  - 수정 : 반복문을 구성하는 페이지의 수보다 적은 양의 프레임을 할당한다면 `매 반복(iteration)마다 적어도 한 번 이상의 페이지 부재가 발생해 결과적으로 시스템의 성능이 현저히 떨어지게 된다.`
- 2-3. 한 가지 프로세스에 대해 최소한으로 필요한 메모리의 양은 `현준이가 점심먹는 시간이거나 현준이가 꿈꾸는 시간이거나 항상 똑같다`
  - 수정 : 한 가지 프로세스에 대해 최소한으로 필요한 메모리의 양은 `시간에 따라 다를 수 있다.`

</div>
</details>
<br><br>

### 8-4 :fallen_leaf: 전역교체와 지역교체	　`daelee`
 
1. `_____` 알고리즘을 
   - `_______`을 대상으로 적용할 때를 **전역교체** 방법이라하고, 
   - `_______`을 대상으로 적용할 때를 **지역교체** 방법이라 한다.
2. 전역교체 방식은 페이지 교체 시 다른 프로세스에 할당된 프레임을 빼앗아올 수 있다. 이는 운영체제가 스스로 `___________`을 조절하는 또 다른 방법이 될 수 있다.


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
1. 페이지 교체 알고리즘을 
   - 물리적 메모리 내에 존재하는 전체 프레임을 대상으로 적용할 때를 전역교체 방법이라하고, 
   - 프로세스별로 독자적으로 적용할 때를 지역교체 방법이라 한다.
2. 전역교체 방식은 페이지 교체 시 다른 프로세스에 할당된 프레임을 빼앗아올 수 있다. 이는 프로세스별 프레임 할당량을 조절하는 또 다른 방법이 될 수 있다. 

</div>
</details>
<br><br>

### 8-5 :fallen_leaf: 스레싱 	　`secho`
 
 
2020년 10월 29일 오전 10시

지잉 지잉..

`현준`은 문자메시지를 받았다.

발신자 : OS과목 이태혁 교수님
<br>
[web발신] 중간고사 관련 공지
<br>
OS 1권부터 5권까지에서 문제 출제
<br>
범위는 x장부터 xx장까지 
<br>
11월 3일
<br>
시험시간 10:00


<br>

시험일이 코앞까지 다가온
`현준`은 공부를 하려고 책상앞에 앉았다.
`현준`의 공부스타일은 모든 자료와 책을 한꺼번에 펼쳐서 공부하는 편이다.

그래서 책 5권을 한 책상에 펼쳐서 공부를 시작했다.

그러나 펼친 책 5권은 `현준`이 받아들이기에 너무 많은 양이었다.
`현준`은 공부 방향을 정하지 못해 이내 뇌정지가 되었다.

`현준`은 **자신도 모르게** 알 수 없는 불안감이 들면서 어느새 OS관련 책을 이것저것 펼치기 시작했다.

펼쳐놓은 책이 20권에 달할때쯔음 `현준`은 당연하게도 20권을 전부 볼 수 없었고

각 각의 책에 대한 집중력도 계속해서 떨어져갔다.

결국 현준은 펼쳐놓은 책을 덮고 책장에 꽂은뒤, 다시 다른 책을 빼어 펼쳤지만

이내 다시 책장에 꼽고 또 다른책을 꺼내는 등의 행위를 반복하면서 `현준`은 공부를 거의 하지 못했다.

<br>

1번. 이때 `현준`에게 발생한 현상은 OS에서는 뭐라고할까?
<br>
2번. `현준`은 책을 계속해서 펼쳐갔는데 왜 이런 행동을 하게 되었을까?
<br>
3번. `현준`은 책을 책장에 꼽았다 넣었다하는 행동을 반복했다. 이는 OS의 `프로세스`들이 서로의 페이지를 `__`하여 `___`, `____`을 반복하는 것과 유사하다. 
<br>

이런 상황을 보다못한 `거니`는 `현준`에게 등짝스매싱을 날리고 기말고사를 제대로 준비할 수 있는 2가지 방법을 제시했다.

<br>
4번. 2가지 방법의 이름은 무엇이고, 각각에 대해서 짧게 설명해볼까..랄까?
<br>
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
1번. 쓰레싱현상
2번. 집중(반복)적으로 참조되는 페이지들의 집합을 메모리에 올리지 못하면 부재율이 상승해 CPU이용률이 낮아지게 되는데 OS는 이런 상황을 인지하지 못하고 이용률을 높이기 위해 PS를 메모리에 더 많이 올리기 시작한다.
3번. MPD가 높아지고 페이지 부재가 발생하면서 프로세스들은 페이지를 교체하는데 이때 스왑인, 아웃을 반복하면서 결국 CPU는 일을 하지 못한다.
  
4번
워킹셋 알고리즘
 - 집중참조 페이지 보장
 - 모두 못올리면 스왑아웃
 - 윈도우 크기에 따라 CPU이용률이 달라질 수 있음, 메모리 필요에 따라 동적으로 프레임할당
페이지 부재빈도알고리즘
- 페이지 부재유 조사해 메모리 양 동적으로 조절
- 부재율이 상한선 넘으면 그 프로세스에 프레임 추가할당, 없으면 일부 프로세스 스왑아웃
- 하한선 이하면 그 프로세스 프레임 줄임, 모두 할당하고 프레임 남으면 스왑 아웃된 프로세스에게 프레임 할당

</div>
</details>
<br><br>
