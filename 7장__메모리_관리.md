
## 7장 메모리 관리

<br>

### 7-1 :fallen_leaf: 주소 바인딩　`secho`

1번.

`물리적 주소, 물리넷 주소, 논리적 주소, 논리적 메모리, 물리적 메모리, 엉기적 메모리`

`아가대리 프로그램`은 메모리에 적재되어 주소공간을 생성했다. 이 주소공간을 `___ __`라고 하며, `아가대리 프로그램`이 사용자 `쿠킴`에게 실행되기 위해서 `___ ___`에 올라가 있어야 하며 CPU인 `개킴`의 기계어 명령을 수행하기 위해  논리적 주소를 통해 메모리 참조를 하면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야한다.

<br>

2번.

주소 바인딩이란 무엇인지와 3가지 종류에 대해서 말씀해주세요.

<br>

3번

문제 : `한계 레지스터`없는 MMU기법에서 나올 수 있는 문제점과 이를 방지해주는`한계 레지스터, 기준레지스터`의 역할은 뭘까요?




<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

1번.

`물리적 주소, 물리넷 주소, 논리적 주소, 논리적 메모리, 물리적 메모리, 엉기적 메모리`

`아가대리 프로그램`은 메모리에 적재되어 주소공간을 생성했다. 이 주소공간을 `논리적 주소`라고 하며, `아가대리 프로그램`이 사용자 `쿠킴`에게 실행되기 위해서 `물리적 메모리`에 올라가 있어야 하며 CPU인 `개킴`의 기계어 명령을 수행하기 위해서  논리적 주소를 통해 메모리 참조를 하면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야한다.



2번.

주소 바인딩이란 무엇인지와 3가지 종류에 대해서 말씀해주세요.

프로세스의 논리적 주소 = 물리적 주소로 연결시키는 작업을 **주소 바인딩**이라 한다.

컴파일 타임 바인딩, 로드 타임 바인딩, 실행시간 바인딩

![image](https://user-images.githubusercontent.com/55486644/97109874-29552800-1719-11eb-9a32-d6eff02b22f7.png)

- 컴파일 타임 바인딩: 프로그램을 컴파일할 때 물리적 메모리주소가 결정됨 (물리적 메모리주소 === 논리적(프로그램 )메모리 주소) 
  - 프로그램 내 주소인 0번 10번 20번 ..의 논리적 주소가 물리적 주소로 그대로 결정됨
  - 이미 다른 프로세스에서 사용하고 있는 메모리주소가 있을 수 있기에 이 방법은 현재 거의 안씀 - 아두이노같은 경우에는 사용(한 프로그램만 돌아감)
- 로드 타임 바인딩 : 프로그램 **실행이 시작될 때** 물리적 주소가 결정
  - 프로그램 종료까지 물리적 메모리 위치 고정
  - 실행될 때마다 주소가 변경되므로 프로그램 내의 메모리 주소 전체를 어디에 로딩되는지에 따라 주소를 전부 다 바꿔주어야함. -> 메모리 로딩시간이 긺 -> 안씀
- 실행시간 바인딩 : 실행 이후, 메모리 주소가 변경될 수 있음
  - 기준, 한계, MMU 하드웨어의 지원으로 가능
  - load타임과 같은데  물리적 메모리에서 HW가 메모리 주소를 매핑시켜줌



3번

문제 : `한계 레지스터`없는 MMU기법에서 나올 수 있는 문제점과 이를 방지해주는`한계 레지스터, 기준레지스터`의 역할은 뭘까요?

- 기준 레지스터만 있을 때 해당 프로세스의 주소공간의 범위를 몰라 범위를 넘어서서 다른 곳으로 침범할 수 있는 `메모리보안`이 이루어지지 않아 치명적 결과가 발생할 수 있는데 프로세스의 크기를 담는 `한계 프로세스`를 통해 cpu가 요청한 프로세스의 논리적 주소값이 자신 프로세스의 크기보다 작은지 확인하여 방지할 수 있음.

</div>
</details>
<br><br>

### 7-2 :fallen_leaf: 메모리 관리와 관련된 용어	　`jehong`
 
#### PART 1

보기에서 알맞은 단어를 찾아 빈칸을 채우세요.

`동적 로딩 (dynamic loading)`<br>`동적 연결 (dynamic linking)`<br>`중첩 (overlays)`<br>`스텁(stub)`<br>`스왑 영역 (swap area)`<br>`스와핑 (swapping)`<br>`스왑 아웃 (swap out)`<br>`스왑 인 (swap in)`<br>`전송 시간 (transfer time)`<br>`로드 타임 바인딩`<br>`컴파일 타임 바인딩`<br>`다중 프로그래밍의 정도`<br>`실행시간 바인딩`<br>`짧은`<br>`긴`<br>`비휘발성`<br>`휘발성`<br>



1. `___________` 은/는 동적연결을 가능하게 하기 위한 코드로 라이브러리 호출 시 **해당 라이브러리가 메모리에 이미 존재하는지** 살펴보는데 쓰인다.
2. 디스크에서 메모리로 올리는 작업을 `___________`, 메모리에서 디스크로 내리는 작업을 `___________` 이라고 부른다.
3. 파일 시스템은 전원이 나가더라도 그 내용이 유지되어야 하는 `________` 저장공간임에 비해 스왑 영역은 저장 기간이 상대적으로 `_____` 저장공간이라고 할 수 있다.
4. `___________` 이란/란 프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법으로 **단일 프로세스 환경에서 메모리 용량보다 큰 프로세스를 실행**하기 위한 방법이다.
5. `_____________` 은/는 프로세스 내에서 **실행에 필요한 부분**이 불릴 때마다 그 부분만을 메모리에 적재해 메모리 이용률을 향상시킨 기법이다.
6. `_____________` 은/는 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성되는 기법이다.
7. `_____________` 은/는 컴파일을 통해 생성된 목적파일과 라이브러리 파일이 프로그램의 **실행 시점에 연결**되는 기법이다. 
8. 스와핑의 가장 중요한 역할은 **메모리에 존재하는 프로세스의 수를 조절**, 즉 `____________` 을/를 조절하는 것이다.
9. 스와핑에서 `_____________` 방식과 `_____________ `방식에서는 스왑 아웃된 프로세스가 다시 스왑 인될 때 원래 존재하던 메모리 위치로 다시 올라가야 하는 반면 `_____________` 방식에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있다.
10. 스와핑에 소요되는 시간은 탐색시간이나 회전지연시간보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 `____________` 이 대부분을 차지한다. 



<br>

#### PART 2

1. 중첩과 동적 로딩의 차이점은 무엇인가요?
2. 스와핑을 설명해주세요.





<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### PART 1

보기에서 알맞은 단어를 찾아 빈칸을 채우세요.

`동적 로딩 (dynamic loading)`<br>`동적 연결 (dynamic linking)`<br>`중첩 (overlays)`<br>`스텁(stub)`<br>`스왑 영역 (swap area)`<br>`스와핑 (swapping)`<br>`스왑 아웃 (swap out)`<br>`스왑 인 (swap in)`<br>`전송 시간 (transfer time)`<br>`로드 타임 바인딩`<br>`컴파일 타임 바인딩`<br>`다중 프로그래밍의 정도`<br>`실행시간 바인딩`<br>`짧은`<br>`긴`<br>`비휘발성`<br>`휘발성`<br>

1. `스텁(stub)` 은 동적연결을 가능하게 하기 위한 코드로 라이브러리 호출 시 **해당 라이브러리가 메모리에 이미 존재하는지** 살펴보는데 쓰인다.

   > 라이브러리 호출 시 **스텁**을 통해 **해당 라이브러리가 메모리에 이미 존재하는지** 살펴보고 그럴 경우 그 주소의 메모리 위치에서 직접 참조하며, 그렇지 않을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재한 후 수행하게 된다.

2. 디스크에서 메모리로 올리는 작업을 `스왑 인 (swap in)`, 메모리에서 디스크로 내리는 작업을 `스왑 아웃 (swap out)` 이라고 부른다.

3. 파일 시스템은 전원이 나가더라도 그 내용이 유지되어야 하는 `비휘발성` 저장공간임에 비해 스왑 영역은 저장 기간이 상대적으로 `짧은` 저장공간이라고 할 수 있다.

   > **스왑 영역**은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장 기간이 상대적으로 **짧은** 저장공간이라고 할 수 있다.

4. `중첩 (overlays)` 란 프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법으로 **단일 프로세스 환경에서 메모리 용량보다 큰 프로세스를 실행**하기 위한 방법이다.

5. `동적 로딩 (dynamic loading)` 은 프로세스 내에서 **실행에 필요한 부분**이 불릴 때마다 그 부분만을 메모리에 적재해 메모리 이용률을 향상시킨 기법이다. 

6. `정적 연결 (static linking)` 은 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성되는 기법이다.

   > 실행파일의 크기가 상대적으로 크며 **동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재**해야 하므로 물리적 메모리가 낭비되는 단점이 있다.

7. `동적 연결 (dynamic linking)` 은 컴파일을 통해 생성된 목적파일과 라이브러리 파일이 프로그램의 **실행 시점에 연결**되는 기법이다. 

   > 다수의 프로그램이 **공통으로 사용하는 라이브러리를 메모리에 한 번만 적재**하므로 메모리 사용의 효율성을 높일 수 있다.

8. 스와핑의 가장 중요한 역할은 **메모리에 존재하는 프로세스의 수를 조절**, 즉 `다중 프로그래밍의 정도` 를 조절하는 것이다.

9. 스와핑에서 `컴파일 타임 바인딩` 방식과 `로드 타임 바인딩` 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인될 때 원래 존재하던 메모리 위치로 다시 올라가야 하는 반면 `실행시간 바인딩` 방식에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있다.

10. 스와핑에 소요되는 시간은 탐색시간이나 회전지연시간보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 `전송 시간 (transfer time)` 이 대부분을 차지한다. 



<br>

#### PART 2

1. 중첩과 동적 로딩의 차이점은 무엇인가요?

   > 동적로딩과 개념적으로 유사하나 사용하는 이유가 상이하다. **중첩**은 **프로그램의 크기가 물리적 메모리의 크기에 비해 작은 경우 어쩔 수 없이** 프로세스의 주소 공간을 분할해 메모리에 올리는 기법이지만 동적로딩은 더 많은 프로세스를 동시에 올려놓고 실행하기 위해 **주소 공간 중 당장 실행에 필요한 부분만 메모리에 적재**하는 방식으로 메모리 사용의 효율성을 높인다.

2. 스와핑을 설명해주세요.

   >**스와핑 (swapping)** 이란 메모리에 올라온 프로세스의 주소 공간 전체를 **스왑 영역 (swap area)** 에 일시적으로 내려놓는 것을 말한다. 
   >
   >너무 많은 프로그램이 메모리에 동시에 올라오면 프로세스당 할당되는 메모리의 양이 지나치게 적어져 시스템 전체의 성능이 크게 떨어진다. 스와핑은 일부 프로그램을 **스왑 아웃**시켜 이러한 문제를 해결한다. 스와핑은 스와퍼라 불리는 중기 스케줄러에 의해 스왑아웃시킬 프로세스를 선정해 해당 **프로세스를 통째로 스왑 아웃시켜 남아있는 프로그램들에게 필요한 메모리 공간을 보장**한다. 

</div>
</details>
<br><br>

### 7-3 :fallen_leaf: 물리적 메모리의 할당 방식	　`taelee`
 
문제 작성


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>

### 7-4 :fallen_leaf: 페이징 기법	　`yeosong`
 
문제 작성


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>

### 7-5 :fallen_leaf: 세그먼테이션 	　`kukim`

#### 보기를 이용해 아래의 괄호를 채우세요.

##### 보기
`physical unit(물리적인 단위)`,`logical unit(논리적인 단위)`, `길이가 동일`, `길이`, `페이징`, `세그먼테이션`, `짧은`, `보조 오프셋`, `세그먼트 정렬`, `os 스터디 꿀잼`

1. 세그먼테이션 기법은 메모리 공간을 `(     )`로 나눈 것을 뜻한다.
2.  페이징 기법은 모든 페이지의 `(     )` 하므로, 페이지 테이블의 항목에 기준점이라 할 수 있는 페이지 프레임 위치만 유지하고 있으면 된다. 하지만 세그먼테이션 기법에서는 세그먼트의 길이가 `(     )`하지 않다.
3.  세그먼테이션 기법은 페이징 기법과 유사하게 테이블을 사용하여 물리 메모리 주소에 접근한다. 페이징 테이블은 <페이지 번호, 오프셋>으로 구현되어 있고 세그먼트 테이블은  <세그먼트 번호, 오프셋>에 < `(     )` > 를 더하여 구현되어있다.
4. +a) 리눅스 OS의 프로세스 메모리 할당 기법은 `(     )` 기반으로 구현되어있다.

#### 세그먼테이션 기법 활용 예
- x86 리얼모드 (CS, DS, SS, ES로 세그먼트를 나누어 메모리 접근)
- 인텔의 x86으로 업그레이드(80286버전, CPU의 protection ring, 보호모드 추가)되면서 기존의 8086/80186 CPU칩셋이 돌아가지 않는 문제를 해결하기 위해 세그멘테이션 기법을 사용하여 과거의 CPU 버전을 세그먼트로 나누어, 메모리 접근함

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
#### 보기를 이용해 아래의 괄호를 채우세요.
##### 보기
`physical unit(물리적인 단위)`,`logical unit(논리적인 단위)`, `길이가 동일`, `길이`, `페이징`, `세그먼테이션`, `짧은`, `보조 오프셋`, `세그먼트 정렬`, `os 스터디 꿀잼`

1. 세그먼테이션 기법은 메모리 공간을 (`logical unit(논리적인 단위)`)로 나눈 것을 뜻한다.
2.  페이징 기법은 모든 페이지의 (`길이가 동일`) 하므로, 페이지 테이블의 항목에 기준점이라 할 수 있는 페이지 프레임 위치만 유지하고 있으면 된다. 하지만 세그먼테이션 기법에서는 세그먼트의 길이가 (`길이가 동일`)하지 않다.
3.  세그먼테이션 기법은 페이징 기법과 유사하게 테이블을 사용하여 물리 메모리 주소에 접근한다. 페이징 테이블은 <페이지 번호, 오프셋>으로 구현되어 있고 세그먼트 테이블은  <세그먼트 번호, 오프셋>에 < (`길이`) > 를 더하여 구현되어있다.
4. +a) 리눅스 OS의 프로세스 메모리 할당 기법은 (`페이징`) 기반으로 구현되어있다.

#### 세그먼테이션 기법 활용 예
- x86 리얼모드 (CS, DS, SS, ES로 세그먼트를 나누어 메모리 접근)
- 인텔의 x86으로 업그레이드(80286버전, CPU의 protection ring, 보호모드 추가)되면서 기존의 8086/80186 CPU칩셋이 돌아가지 않는 문제를 해결하기 위해 세그멘테이션 기법을 사용하여 과거의 CPU 버전을 세그먼트로 나누어, 메모리 접근함

</div>
</details>
<br><br>

### 7-6 :fallen_leaf: 페이지드 세그먼테이션 	　`gaekim`
 
문제 작성


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>
