
## 6장 CPU 스케줄링

<br>

### 6-1 :fallen_leaf: CPU 스케줄러　`yeosong`
 
#### CPU 스케줄링: 비선점형 nonpreemtive 방식 / 선점형 preemtive 방식 구분하기

1. 프로그램 `printf`를 실행하던 중 코드 내용 중에 출력을 하는 부분이 있어서, <br>
I/O 인터럽트 루틴을 따르는 동안 프로세스 `printf`는 blocked(봉쇄) 상태가 되었다. 이 경우의 CPU 스케줄링 방식은?


2. 아래와 같은 프로그램의 실행을 무사히 마친 프로세스 `kido`가 종료되고, CPU 제어권을 잃었다. 이 경우의 CPU 스케줄링 방식은?

```C
#include <stdio.h>
int main()
{
  printf("%s\n", "kido calm down.");
} 
```



3. 프로그램 `푸쉬업`이 실행되던 중 입출력 인터럽트가 들어와 `푸쉬업`은 봉쇄 상태가 되었다.<br>
들어왔던 입출력 인터럽트 종료 후 `푸쉬업`가 다시 실행될 줄 알았지만..<br>
최우선순위 프로세스로 설정되어 있었던 프로세스 `꼬북칩`으로 CPU가 이양되는 바람에<br>
`푸쉬업`은 준비 상태로 돌아가버렸다. 이 경우의 CPU 스케줄링 방식은?


4. 작업량이 방대한 프로세스 `42`는 타이머 인터럽트에 걸려 준비 상태로 변경되었다. 이 경우의 CPU 스케줄링 방식은?


5. (보너스 문제) `CPU 스케줄러`는 특정한 하드웨어일까요? 혹은 소프트웨어? 독립된 소프트웨어일까요?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
#### CPU 스케줄링: 비선점형 nonpreemtive 방식 / 선점형 preemtive 방식 구분하기

1. 프로그램 `printf`를 실행하던 중 코드 내용 중에 출력을 하는 부분이 있어서, <br>
I/O 인터럽트 루틴을 따르는 동안 프로세스 `printf`는 blocked(봉쇄) 상태가 되었다. 이 경우의 CPU 스케줄링 방식은?
> 프로세스가 입출력 인터럽트를 위해 CPU를 자발적으로 이양하는 것이므로 비선점형.

2. 아래와 같은 프로그램의 실행을 무사히 마친 프로세스 `kido`가 종료되고, CPU 제어권을 잃었다. 이 경우의 CPU 스케줄링 방식은?

```C
#include <stdio.h>
int main()
{
 printf("%s\n", "kido calm down.");
} 
```

> 프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 exit() 시스템 콜을 넣어줘서,<br>
> 자발적으로 CPU를 반납하고 종료되는 상황이다. 그러므로 비선점형.



3. 프로그램 `푸쉬업`이 실행되던 중 입출력 인터럽트가 들어와 `푸쉬업`은 봉쇄 상태가 되었다.<br>
들어왔던 입출력 인터럽트 종료 후 `푸쉬업`가 다시 실행될 줄 알았지만..<br>
최우선순위 프로세스로 설정되어 있었던 프로세스 `꼬북칩`으로 CPU가 이양되는 바람에<br>
`푸쉬업`은 준비 상태로 돌아가버렸다. 이 경우의 CPU 스케줄링 방식은?
> 최우선순위로 선점되어 있어서 이를 위해 CPU를 빼앗아 간 것이므로 선점형.

4. 작업량이 방대한 프로세스 `42`는 타이머 인터럽트에 걸려 준비 상태로 변경되었다. 이 경우의 CPU 스케줄링 방식은?
> 시간이 선점되어 있어서 이를 지키기 위해 빼앗아 간 것이므로 선점형.


5. (보너스 문제) `CPU 스케줄러`는 특정한 하드웨어일까요? 혹은 소프트웨어? 독립된 소프트웨어일까요?
> 운영체제 내에 있는 코드 중에 스케줄링을 어떻게 할지에 대한 내용이 들어있는 부분이 있는데 이를 `CPU 스케줄러`라고 부르는 것입니다. <br>
> [반효경 교수님 강의중 59분쯤](https://core.ewha.ac.kr/publicview/C0101020140325134428879622?vmode=f)

</div>
</details>
<br><br>

### 6-2 :fallen_leaf: 디스패처	　`kukim`
 
1. 디스패처(dispatcher)이란 무엇인가요? (주관식)  

2. 디스패치 지연시간(dispatch latency)이란 무엇인가요? (주관식)  

3. 디스패치 지연시간의 대부분은 어디에 해당될까요? (보기 선택)
```
보기 : 파파라치 사진찍기, 오버헤드킥, 문맥교환 오버헤드, PCB I/O,  CPU bound process
```

4. 다음은 디스패처의 수행 작업 과정이다. 보기에서 괄호를 채우시오.

```
보기 : PC, SP, PCB, 디스패치, 찰칵찰칵, SD 카드
```

현재 수행중이던 프로세스의 문맥(context)을 그 프로세스의 (   )에 저장하고

새롭게 선택된 프로세스의 문맥을 (   )로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행한다.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
1. 디스패처(dispatcher)이란 무엇인가요? (주관식)  
정답 : CPU 스케줄러가 어떤 프로세스에게 CPU를 할당해야 할지 결정하고나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요한데 이때 새롭게 선택된 CPU를 할당, 작업 수행할 수 있도록 환경설정 하는 운영체제의 코드이다.

2. 디스패치 지연시간(dispatch latency)이란 무엇인가요? (단답형)  
디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간

3. 디스패치 지연시간의 대부분은 어디에 해당될까요?
```
보기 : 파파라치 사진찍기, 오버헤드킥, 문맥교환 오버헤드, PCB I/O,  CPU bound process
```
정답 : 문맥교환 오버헤드

4. 다음은 디스패처의 수행 작업 과정이다. 괄호를 채우시오.

```
보기 : PC, SP, PCB, 디스패치, 찰칵찰칵, SD 카드
```

현재 수행중이던 프로세스의 문맥(context)을 그 프로세스의 (PCB)에 저장하고

새롭게 선택된 프로세스의 문맥을 (PCB)로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행한다.
</div>
</details>
<br><br>


### 6-3 :fallen_leaf: 스케줄링의 성능 평가	　`gaekim`
 
1. 스케줄링의 성능 평가 지표는 시스템 관점의 지표와 사용자 관점의 지표로 분류할 수 있다. 시스템 관점의 지표로는 `CPU 이용률`과 `처리량`이 있고, 사용자 관점의 지표로는 `소요시간`[=총 처리시간], `대기시간`, `응답시간` 등 기다린 `시간`과 관련된 지표들이 있다.
> CPU 이용률: 전체 시간 중에서 CPU가 일을 한 시간의 비율
> 처리량: 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지 나타낸다. (=CPU 버스트를 완료한 프로세스의 개수)
> 소요시간: 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간, 즉 준비 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합을 뜻한다.
> 대기시간: CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
> 응답시간: 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간

2. 여러 프로세스가 CPU를 기다리고 있는 상황에서, 주어진 시간에 더 많은 프로세스들이 CPU 작업을 완료하기 위해서는 CPU 버스트가 `짧은 / 긴` 프로세스에게 우선적으로 CPU를 할당하는 것이 유리하다.

3. `응답시간`은 CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합을 뜻한다. `(O / X)`
> 시분할 시스템에서는 일반적으로 타이머를 사용해서 하나의 프로세스가 CPU를 연속적으로 사용할 수 있는 시간을 제한한다. 따라서 한 번의 CPU 버스트 중에도 준비 큐에서 기다린 시간이 여러 번 발생할 수 있다. 이때 대기시간이란 이번 CPU 버스트가 끝나기까지 준비 큐에서 기다린 시간의 합을 뭇하게 된다.

4. 일반적으로 `CPU 이용률`과 `처리량`은 `최대화`하고 `소요시간`, `대기시간`, `응답시간`은 `최소화`하는 것이 바람직하다.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>

### 6-4 :fallen_leaf: 스케줄링 알고리즘	　`mihykim`
 
문제 작성


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>

### 6-5 :fallen_leaf: 스케줄링 알고리즘의 평가 	　`daelee`
 
- 스케줄링 알고리즘의 성능을 평가하는 방법으로는 `____`, `____`, `______` 방식이 있다.

  ```
  보기 : 시뮬레이션, 뿌잉모델, 트레이스(trace), 구현, 나현, 다현, 대현, 실측, 로드 타임 바인딩, 큐잉모델, 세그먼테이션 기법, 구현 및 실측, 페이징, 고정분할
  ```


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- 스케줄링 알고리즘의 성능을 평가하는 방법으로는 `____`, `____`, `______` 방식이 있다.

  ```
  시뮬레이션, 뿌잉모델, 트레이스(trace), 구현, 나현, 다현, 대현, 실측, 로드 타임 바인딩, 큐잉모델, 세그먼테이션 기법, 구현 및 실측, 페이징, 고정분할
  ```

  > 정답 : 큐잉모델, 시뮬레이션, 구현 및 실측
  >
  > - **큐잉모델(que-ueing model)** : 확률분포를 통해 프로세스의 도착률과 cpu 처리율을 입력값으로 준 뒤 각종 성능지표(cpu의 처리량, 프로세스의 평균 대기시간 등)를 구하는 방식
  > - **구현 및 실측(implementation & measurement) :** 운영체제 커널의 cpu 스케줄링 코드를 수정해, 동일한 프로그램을 원래 커널과 수정한 커널에서 수행시켜보고 실행시간을 측정/비교하는 방식
  > - **시뮬레이션(simulation) :** 가상으로 cpu 스케줄링 프로그램을 작성해 결과를 확인하는 방식. 입력값은 실제 시스템에서의 cpu 요청내역을 추출해 사용하기도 하는데, 이 값을 `트레이스(trace)`라고 부른다.

  

</div>
</details>
<br><br>
