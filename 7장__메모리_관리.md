
## 7장 메모리 관리

<br>

### 7-1 :fallen_leaf: 주소 바인딩　`secho`

1번.

`물리적 주소, 물리넷 주소, 논리적 주소, 논리적 메모리, 물리적 메모리, 엉기적 메모리`

`아가대리 프로그램`은 메모리에 적재되어 주소공간을 생성했다. 이 주소공간을 `___ __`라고 하며, `아가대리 프로그램`이 사용자 `쿠킴`에게 실행되기 위해서 `___ ___`에 올라가 있어야 하며 CPU인 `개킴`의 기계어 명령을 수행하기 위해  논리적 주소를 통해 메모리 참조를 하면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야한다.

<br>

2번.

주소 바인딩이란 무엇인지와 3가지 종류에 대해서 말씀해주세요.

<br>

3번

문제 : `한계 레지스터`없는 MMU기법에서 나올 수 있는 문제점과 이를 방지해주는`한계 레지스터, 기준레지스터`의 역할은 뭘까요?





<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


1번.

`물리적 주소, 물리넷 주소, 논리적 주소, 논리적 메모리, 물리적 메모리, 엉기적 메모리`

`아가대리 프로그램`은 메모리에 적재되어 주소공간을 생성했다. 이 주소공간을 `논리적 주소`라고 하며, `아가대리 프로그램`이 사용자 `쿠킴`에게 실행되기 위해서 `물리적 메모리`에 올라가 있어야 하며 CPU인 `개킴`의 기계어 명령을 수행하기 위해서  논리적 주소를 통해 메모리 참조를 하면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야한다.



2번.

주소 바인딩이란 무엇인지와 3가지 종류에 대해서 말씀해주세요.

프로세스의 논리적 주소 = 물리적 주소로 연결시키는 작업을 **주소 바인딩**이라 한다.

컴파일 타임 바인딩, 로드 타임 바인딩, 실행시간 바인딩

![image](https://user-images.githubusercontent.com/55486644/97109874-29552800-1719-11eb-9a32-d6eff02b22f7.png)

- 컴파일 타임 바인딩: 프로그램을 컴파일할 때 물리적 메모리주소가 결정됨 (물리적 메모리주소 === 논리적(프로그램 )메모리 주소) 
  - 프로그램 내 주소인 0번 10번 20번 ..의 논리적 주소가 물리적 주소로 그대로 결정됨
  - 이미 다른 프로세스에서 사용하고 있는 메모리주소가 있을 수 있기에 이 방법은 현재 거의 안씀 - 아두이노같은 경우에는 사용(한 프로그램만 돌아감)
- 로드 타임 바인딩 : 프로그램 **실행이 시작될 때** 물리적 주소가 결정
  - 프로그램 종료까지 물리적 메모리 위치 고정
  - 실행될 때마다 주소가 변경되므로 프로그램 내의 메모리 주소 전체를 어디에 로딩되는지에 따라 주소를 전부 다 바꿔주어야함. -> 메모리 로딩시간이 긺 -> 안씀
- 실행시간 바인딩 : 실행 이후, 메모리 주소가 변경될 수 있음
  - 기준, 한계, MMU 하드웨어의 지원으로 가능
  - load타임과 같은데  물리적 메모리에서 HW가 메모리 주소를 매핑시켜줌

</div>
</details>
<br><br>

### 7-2 :fallen_leaf: 메모리 관리와 관련된 용어	　`jehong`
 
#### PART 1

보기에서 알맞은 단어를 찾아 빈칸을 채우세요.

`동적 연결 (dynamic linking)`, `정적 연결 (static linking)`<br>

`동적 로딩 (dynamic loading)`, `중첩 (overlays)`, `스텁(stub)`<br>

`스왑 영역 (swap area)`, `스와핑 (swapping)`<br>

`스왑 아웃 (swap out)`, `스왑 인 (swap in)`<br>

`로드 타임 바인딩`, `컴파일 타임 바인딩`, `실행시간 바인딩`<br>

`다중 프로그래밍의 정도`, `전송 시간 (transfer time)`<br>

`짧은`, `긴`, `비휘발성`, `휘발성`<br>



1. `___________` 은/는 동적연결을 가능하게 하기 위한 코드로 라이브러리 호출 시 **해당 라이브러리가 메모리에 이미 존재하는지** 살펴보는데 쓰인다.
2. 디스크에서 메모리로 올리는 작업을 `___________`, 메모리에서 디스크로 내리는 작업을 `___________` 이라고 부른다.
3. 파일 시스템은 전원이 나가더라도 그 내용이 유지되어야 하는 `________` 저장공간임에 비해 스왑 영역은 저장 기간이 상대적으로 `_____` 저장공간이라고 할 수 있다.
4. `___________` 이란/란 프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법으로 **단일 프로세스 환경에서 메모리 용량보다 큰 프로세스를 실행**하기 위한 방법이다.
5. `_____________` 은/는 프로세스 내에서 **실행에 필요한 부분**이 불릴 때마다 그 부분만을 메모리에 적재해 메모리 이용률을 향상시킨 기법이다.
6. `_____________` 은/는 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성되는 기법이다.
7. `_____________` 은/는 컴파일을 통해 생성된 목적파일과 라이브러리 파일이 프로그램의 **실행 시점에 연결**되는 기법이다. 
8. 스와핑의 가장 중요한 역할은 **메모리에 존재하는 프로세스의 수를 조절**, 즉 `____________` 을/를 조절하는 것이다.
9. 스와핑에서 `_____________` 방식과 `_____________ `방식에서는 스왑 아웃된 프로세스가 다시 스왑 인될 때 원래 존재하던 메모리 위치로 다시 올라가야 하는 반면 `_____________` 방식에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있다.
10. 스와핑에 소요되는 시간은 탐색시간이나 회전지연시간보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 `____________` 이 대부분을 차지한다. 



<br>

#### PART 2

1. 중첩과 동적 로딩의 차이점은 무엇인가요?
2. 스와핑을 설명해주세요.





<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### PART 1

보기에서 알맞은 단어를 찾아 빈칸을 채우세요.

`동적 연결 (dynamic linking)`, `정적 연결 (static linking)`<br>

`동적 로딩 (dynamic loading)`, `중첩 (overlays)`, `스텁(stub)`<br>

`스왑 영역 (swap area)`, `스와핑 (swapping)`<br>

`스왑 아웃 (swap out)`, `스왑 인 (swap in)`<br>

`로드 타임 바인딩`, `컴파일 타임 바인딩`, `실행시간 바인딩`<br>

`다중 프로그래밍의 정도`, `전송 시간 (transfer time)`<br>

`짧은`, `긴`, `비휘발성`, `휘발성`<br>

1. `스텁(stub)` 은 동적연결을 가능하게 하기 위한 코드로 라이브러리 호출 시 **해당 라이브러리가 메모리에 이미 존재하는지** 살펴보는데 쓰인다.

   > 라이브러리 호출 시 **스텁**을 통해 **해당 라이브러리가 메모리에 이미 존재하는지** 살펴보고 그럴 경우 그 주소의 메모리 위치에서 직접 참조하며, 그렇지 않을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재한 후 수행하게 된다.

2. 디스크에서 메모리로 올리는 작업을 `스왑 인 (swap in)`, 메모리에서 디스크로 내리는 작업을 `스왑 아웃 (swap out)` 이라고 부른다.

3. 파일 시스템은 전원이 나가더라도 그 내용이 유지되어야 하는 `비휘발성` 저장공간임에 비해 스왑 영역은 저장 기간이 상대적으로 `짧은` 저장공간이라고 할 수 있다.

   > **스왑 영역**은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장 기간이 상대적으로 **짧은** 저장공간이라고 할 수 있다.

4. `중첩 (overlays)` 란 프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법으로 **단일 프로세스 환경에서 메모리 용량보다 큰 프로세스를 실행**하기 위한 방법이다.

5. `동적 로딩 (dynamic loading)` 은 프로세스 내에서 **실행에 필요한 부분**이 불릴 때마다 그 부분만을 메모리에 적재해 메모리 이용률을 향상시킨 기법이다. 

6. `정적 연결 (static linking)` 은 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성되는 기법이다.

   > 실행파일의 크기가 상대적으로 크며 **동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재**해야 하므로 물리적 메모리가 낭비되는 단점이 있다.

7. `동적 연결 (dynamic linking)` 은 컴파일을 통해 생성된 목적파일과 라이브러리 파일이 프로그램의 **실행 시점에 연결**되는 기법이다. 

   > 다수의 프로그램이 **공통으로 사용하는 라이브러리를 메모리에 한 번만 적재**하므로 메모리 사용의 효율성을 높일 수 있다.

8. 스와핑의 가장 중요한 역할은 **메모리에 존재하는 프로세스의 수를 조절**, 즉 `다중 프로그래밍의 정도` 를 조절하는 것이다.

9. 스와핑에서 `컴파일 타임 바인딩` 방식과 `로드 타임 바인딩` 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인될 때 원래 존재하던 메모리 위치로 다시 올라가야 하는 반면 `실행시간 바인딩` 방식에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있다.

10. 스와핑에 소요되는 시간은 탐색시간이나 회전지연시간보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 `전송 시간 (transfer time)` 이 대부분을 차지한다. 



<br>

#### PART 2

1. 중첩과 동적 로딩의 차이점은 무엇인가요?

   > 동적로딩과 개념적으로 유사하나 사용하는 이유가 상이하다. **중첩**은 **프로그램의 크기가 물리적 메모리의 크기에 비해 큰 경우 어쩔 수 없이** 프로세스의 주소 공간을 분할해 메모리에 올리는 기법이지만 동적로딩은 더 많은 프로세스를 동시에 올려놓고 실행하기 위해 **주소 공간 중 당장 실행에 필요한 부분만 메모리에 적재**하는 방식으로 메모리 사용의 효율성을 높인다.

2. 스와핑을 설명해주세요.

   >**스와핑 (swapping)** 이란 메모리에 올라온 프로세스의 주소 공간 전체를 **스왑 영역 (swap area)** 에 일시적으로 내려놓는 것을 말한다. 
   >
   >너무 많은 프로그램이 메모리에 동시에 올라오면 프로세스당 할당되는 메모리의 양이 지나치게 적어져 시스템 전체의 성능이 크게 떨어진다. 스와핑은 일부 프로그램을 **스왑 아웃**시켜 이러한 문제를 해결한다. 스와핑은 스와퍼라 불리는 중기 스케줄러에 의해 스왑아웃시킬 프로세스를 선정해 해당 **프로세스를 통째로 스왑 아웃시켜 남아있는 프로그램들에게 필요한 메모리 공간을 보장**한다. 

</div>
</details>
<br><br>

### 7-3 :fallen_leaf: 물리적 메모리의 할당 방식	　`taelee`

단답형 문제의 경우 아래 보기에서 답을 찾아 써주세요 <br>
보기: `운영체제`, `특권영역`, `사용자 프로세스 영역`, `커널`, `운영체제`, `내부`, `외부`, `최초적합(first_fit)방법`, `최고적합(highest-fit)방법`, `최악적합(worst-fit)방법`, `최적적합(best-fit)방법`, `페이징 기법`, `세그먼테이션 기법`, `페이지드 세그먼테이션 기법`, `상주영역`, `고정분할`, `가변분할`
  
1. 물리적 메모리는 운영체제 (a)영역과  (b)영역으로 나뉜다. (a) 영역은  인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용하며, (c)이 이곳에 위치한다. (b) 영역은 물리적 메모리의 높은 주소 영역을 사용하며 여러 사용자 프로세스들이 이곳에 적재되어 실행된다.
2. 연속할당 방식에서는 물리적 메로리를 다수의 분할롤 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다.(O/X)
3. 연속할당 방식에는 (a) 방식과 (b) 방식이 있다.
4. 고정분할 방식은 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있다.(O/X)
5. 고정분할 방식은 수행 가능한 프로그램의 최대 크기가 제한되어 있다.(O/X)
6. OO조각은 해당 조각보다 작은 크기의 프로그램에게 배당될 수 있다.
#### 메모리 가변분할 방식에서는 메모리 할당문제가 중요한 쟁점 중 하나이다. 메모리 할당 문제의 해결 방안 중 다음 예시와 제일 어울리는 방안을 쓰세요
7. 태혁과 정아는 42서울 클러스터에서 항상 붙어 앉는다. 정아는 아침에 우유를 먹어서인지 클러스터를 오는 내내 배가 아팠다. 2층 클러스터에 도착한 정아는 도저히 못참겠어서 제일 처음 보이는 2자리에 자리를 맡아 짐을 내려놓고는 화장실로 뛰어갔다. 이와 제일 비슷한 메모리 할당 문제 해결방식은?
8. 태혁과 정아는 영화관에서 표를 사려고 티켓발급기 앞에 서있다. 남은 자리는 다음과 같다.(하얀색이 빈자리이다.) <br>
![image](https://user-images.githubusercontent.com/55867479/97114402-a7262d00-1733-11eb-9ed5-b4b8128bc497.png)<br>
태혁: 우리 어디 앉을까?<br>
정아: 나는 이런 경우에 며칠전에 배운 메모리 할당문제 해결방식 중 하나인 (a)방식을 따르는게 좋을 것 같아. 영화는 넓게 넓게 앉아서 보는게 최고라고! 자 여기 2자리(초록색) 앉자.<br>
![image](https://user-images.githubusercontent.com/55867479/97114413-b4dbb280-1733-11eb-86c2-14b63f529a33.png)<br>
태혁: 안돼 안돼! 혹시 단체 손님들이 올 수도 있는데 그렇게 앉으면 다른 사람들에게 불편을 끼칠 수 있잖아. 우리 (b) 방식을 따르는건 어때? 여기 파란색으로 2자리를 앉자! 18명되는 대가족이 오랜만에 모여서 영화를 보러 올 수도 있는데 떨어져서 보면 얼마나 마음이 아프겠어<br>
![image](https://user-images.githubusercontent.com/55867479/97114410-aee5d180-1733-11eb-9c24-45a4a090ada3.png)<br>
9. 불연속할당 기법에서 프로그램을 일정한 크기로 나누는 기법을 (a), 크기는 일정하지 않지만 의미 단위로 나누어 메로리에 올리는 기법을 (b), 의미 단위로 나누면서 동일 크기로 다시 나누어 메모리에 올리는 (c) 기법이 있다.



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

단답형 문제의 경우 아래 보기에서 답을 찾아 써주세요<br>
  보기: `운영체제`, `특권영역`, `사용자 프로세스 영역`, `커널`, `운영체제`, `내부`, `외부`, `최초적합(first_fit)방법`, `최고적합(highest-fit)방법`, `최악적합(worst-fit)방법`, `최적적합(best-fit)방법`, `페이징 기법`, `세그먼테이션 기법`, `페이지드 세그먼테이션 기법`, `상주영역`, `고정분할`, `가변분할`

1. 물리적 메모리는 운영체제 (a)영역과  (b)영역으로 나뉜다. (a) 영역은  인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용하며, (c)이 이곳에 위치한다. (b) 영역은 물리적 메모리의 높은 주소 영역을 사용하며 여러 사용자 프로세스들이 이곳에 적재되어 실행된다.
__(a) : 상주영역__
__(b) : 사용자 프로세스 영역__
__(c) : 커널__
2. 연속할당 방식에서는 물리적 메모리를 다수의 분할롤 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다.(O/X)
__O__
3. 연속할당 방식에는 (a) 방식과 (b) 방식이 있다.
__(a) : 고정분할__
__(b) : 가변분할__
4. 고정분할 방식은 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있다.(O/X)
__O__
5. 고정분할 방식은 수행 가능한 프로그램의 최대 크기가 제한되어 있다.(O/X)
__O__
6. OO조각은 해당 조각보다 작은 크기의 프로그램에게 배당될 수 있다.
__외부__
#### 메모리 가변분할 방식에서는 메모리 할당문제가 중요한 쟁점 중 하나이다. 메모리 할당 문제의 해결 방안 중 다음 예시와 제일 어울리는 방안을 쓰세요

7. 태혁과 정아는 42서울 클러스터에서 항상 붙어 앉는다. 정아는 아침에 우유를 먹어서인지 클러스터를 오는 내내 배가 아팠다. 2층 클러스터에 도착한 정아는 도저히 못참겠어서 제일 처음 보이는 2자리에 자리를 맡아 짐을 내려놓고는 화장실로 뛰어갔다. 이와 제일 비슷한 메모리 할당 문제 해결방식은?
__최초적합(first_fit) 방법__

8. 태혁과 정아는 영화관에서 표를 사려고 티켓발급기 앞에 서있다. 남은 자리는 다음과 같다.(하얀색이 빈자리이다.)<br>
![image](https://user-images.githubusercontent.com/55867479/97114402-a7262d00-1733-11eb-9ed5-b4b8128bc497.png)<br>
태혁: 우리 어디 앉을까?<br>
정아: 나는 이런 경우에 며칠전에 배운 메모리 할당문제 해결방식 중 하나인 (a)방식을 따르는게 좋을 것 같아. 영화는 넓게 넓게 앉아서 보는게 최고라고! 자 여기 2자리(초록색) 앉자.<br>
![image](https://user-images.githubusercontent.com/55867479/97114413-b4dbb280-1733-11eb-86c2-14b63f529a33.png)<br>
태혁: 안돼 안돼! 혹시 단체 손님들이 올 수도 있는데 그렇게 앉으면 다른 사람들에게 불편을 끼칠 수 있잖아. 우리 (b) 방식을 따르는건 어때? 여기 파란색으로 2자리를 앉자! 18명되는 대가족이 오랜만에 모여서 영화를 보러 올 수도 있는데 떨어져서 보면 얼마나 마음이 아프겠어<br>
![image](https://user-images.githubusercontent.com/55867479/97114410-aee5d180-1733-11eb-9c24-45a4a090ada3.png)<br>
__(a) : 최악적합(worst_fit)__
__(b) : 최적적합(best-fit)__

10. 불연속할당 기법에서 프로그램을 일정한 크기로 나누는 기법을 (a), 크기는 일정하지 않지만 의미 단위로 나누어 메로리에 올리는 기법을 (b), 의미 단위로 나누면서 동일 크기로 다시 나누어 메모리에 올리는 (c) 기법이 있다.
__(a) : 페이징 기법__
__(b) : 세그먼테이션 기법__
__(c) : 페이지드 세그먼테이션__

</div>
</details>
<br><br>


### 7-4 :fallen_leaf: 페이징 기법	　`yeosong`
 
#### 1. 페이징 기법에서는 `동적 메모리 할당 문제`가 생기지 않는다 그 이유는? (단답식)

#### 2. 다음은 주소 변환 기법에 관한 단어들이다. 내용에 맞게 보기에서 적절한 단어를 골라 넣으세요.

`오프셋` `페이지` `데이터그램` `프레임` `인덱스` `엔트리`

2-1) `____` - 물리적 주소를 나누는 크기 단위
2-2) `____` - 논리적 주소를 나누는 크기 단위
2-3) `____` - 페이지 번호를 인덱스 삼아 따라가면 거기에 페이지의 물리 메모리상의 기준 주소 = 시작위치가 저장되어 있는 것
2-4) `____` - 페이지 내에서 어디에 있는지 위치를 알려주는 것

#### 3. 다음 설명을 읽고, 페이지 테이블의 구현에 관한 알맞은 단어를 골라보세요.

`연관` `독립` `직렬` `병렬` `TCB` `TLB` `메모리 접근 횟수` `TLB 검색 소요 시간` `TCB 실패율` `TLB 적중률`

페이징 기법은 프로세스의 주소 공간을 각각 같은 크기로 쪼개서 물리적 메모리에 올리는 방식이다.<br>
한 번 메모리 접근을 하려면,<br>
주소 변환을 위해(=페이지 테이블을 보고 논리주소를 물리주소로 바꿔와야 하는데, 페이지 테이블이 물리적 메모리에 있어서) 1번,<br>
물리주소를 잘 받아서 그 주소에 있는 실제 데이터에 접근하기 위해 1번.<br>
이렇게 총 2번 메모리에 접근해야한다.<br>
이런 오버헤드를 줄이고 메모리 접근속도를 향상시키기 위해 `캐시 메모리`인 `3-1)___`에 빈번히 접근하는 페이지에 대한 주소 변환 정보를 담아두며,<br>
모든 항목을 동시에 탐색할 수 있도록 `3-2)____` 탐색이 가능한 `3-3)____` 레지스터를 사용한다. <br>
다음은 연관 레지스터 사용시 `평균적인 메모리 접근시간(Effective Access Time)` 계산식이다.

~~~
EAT = (1 + ε)α + (2 + ε)(1 - α)
      ~~~~~~~~   ~~~~~~~~~~~~~
        (가)          (나)
= 2 + ε - α
~~~

여기서 1, 2는 `3-4)________`, <br>
ε은 `3-5)_________`, <br>
α는 `3-6)_________`을 <br>
나타낸다.

3-7) (가) 부분은 TLB 적중이 `성공 / 실패` 했을 경우이다.<br>
3-8) (나) 부분은 TLB 적중이 `성공 / 실패` 했을 경우이다.

#### 계층적 페이징

<img width="604" alt="스크린샷 2020-10-26 오전 7 19 25" src="https://user-images.githubusercontent.com/53321189/97120630-c0db6a80-175b-11eb-91ba-8671aba9cf77.png">

##### 4. 2단계 페이징 기법에서는 현재 사용되지 않는 주소공간(ex 코드에서 핵심연산 부분이 아닌, 예외처리 부분)에 대해서는 `____` 페이지 테이블 항목을 `____`로 설정하여 대응되는 `____` 페이지 테이블을 생성하지 않음으로써 1단계 페이징 기법보다 메모리 낭비를 줄일 수 있다. 

##### 5. n비트로 구분 가능한 서로 다른 위치의 개수는?

##### 6. 32비트 운영체제에서 페이지 하나의 크기는? 

##### 7. 내부 페이지 테이블은 2^10개의 항목을 가지고 있다. 2^10개 항목을 구분하기 위해 필요한 비트의 개수는?

##### 8. 4KB는 2^12바이트이다. 바이트 단위의 오프셋을 표현하기 위한 비트의 개수는?

##### 9. 2단계 페이징에서 논리적 주소를 결정하는 P1, P2, d는 각각 몇 비트를 사용하는가?

##### 10. N단계 페이징을 하면 메모리 접근 1번을 위해서 메모리 접근을 총 N+1번이나 해야한다. 그래도 N단계 페이징을 사용하는 이유가 있다면 그건 무엇일까요?

##### 11. 다음은 4단계 페이징의 EAT 입니다. 각 항목이 의미하는 바를 아래 항목을 이용해 표현해보세요.


~~~
EAT = 0.98 * 120 + 0.02 * 520 = 128
	    ~~~~   ~~~   ~~~~   ~~~
	    (가)   (나)   (다)    (라)
~~~

`α = TLB 적중률` `ε = TLB 탐색시간` `m = 메모리 접근 시간`

예시) 2m + ε * (α - 1)

(가) `______` <br>
(나) `______`  ---------  TLB 성공시 TLB 탐색시간(20) + 실제 데이터에 대한 메모리 접근 시간(100)<br>
(다) `______` ----------------- TLB miss율<br>
(라) `______` ---------------- TLB miss시 TLB 탐색시간(20) + 4단계 접근 시간 (400) + 실제 데이터에 대한 메모리 접근 시간(100)




#### 12. 역페이지 테이블은 프로세스당 페이지 테이블을 하나만 두는 방법을 말한다. (O / X)

#### 13. 공유 코드의 특징 2가지를 적어보세요.

#### 14. 메모리 보호를 위해 존재하는 `보호 비트`는 각 페이지에 누가 접근할 수 있는지 접근 권한의 내용을 담고 있다. (O / X)

#### 15. 메모리 보호를 위해 존재하는 `유효-무효 비트`는 프로세가 백킹스토어에 적재되어 있는 경우, 혹은 현재 사용하지 않는 주소 공간인 경우에 '무효(i)'로 설정된다. (O / X)



--------------------------------------------------------------


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
#### 1. 페이징 기법에서는 `동적 메모리 할당 문제`가 생기지 않는다 그 이유는? (단답식)
> *메모리에 올리는 크기 단위를 모두 같은 크기의 페이지로 쪼개어 놓기 때문에* 빈 자리가 있으면 어디가 나을지, 크기가 맞는지 비교 없이 그냥 들이면 된다.

#### 2. 다음은 주소 변환 기법에 관한 단어들이다. 내용에 맞게 보기에서 적절한 단어를 골라 넣으세요.

`오프셋` `페이지` `데이터그램` `프레임` `인덱스` `엔트리`

2-1) `프레임` - 물리적 주소를 나누는 크기 단위
2-2) `페이지` - 논리적 주소를 나누는 크기 단위
2-3) `엔트리` - 페이지 번호를 인덱스 삼아 따라가면 거기에 페이지의 물리 메모리상의 기준 주소 = 시작위치가 저장되어 있는 것
2-4) `오프셋` - 페이지 내에서 어디에 있는지 위치를 알려주는 것


#### 3. 다음 설명을 읽고, 페이지 테이블의 구현에 관한 알맞은 단어를 골라보세요.

`연관` `독립` `직렬` `병렬` `TCB` `TLB` `메모리 접근 횟수` `TLB 검색 소요 시간` `TCB 실패율` `TLB 적중률`

페이징 기법은 프로세스의 주소 공간을 각각 같은 크기로 쪼개서 물리적 메모리에 올리는 방식이다.<br>
한 번 메모리 접근을 하려면,<br>
주소 변환을 위해(=페이지 테이블을 보고 논리주소를 물리주소로 바꿔와야 하는데, 페이지 테이블이 물리적 메모리에 있어서) 1번,<br>
물리주소를 잘 받아서 그 주소에 있는 실제 데이터에 접근하기 위해 1번.<br>
이렇게 총 2번 메모리에 접근해야한다.<br>
이런 오버헤드를 줄이고 메모리 접근속도를 향상시키기 위해 `캐시 메모리`인 `3-1)TLB`에 빈번히 접근하는 페이지에 대한 주소 변환 정보를 담아두며,<br>
모든 항목을 동시에 탐색할 수 있도록 `3-2)병렬` 탐색이 가능한 `3-3)연관` 레지스터를 사용한다. <br>
다음은 연관 레지스터 사용시 `평균적인 메모리 접근시간(Effective Access Time)` 계산식이다.

~~~
EAT = (1 + ε)α + (2 + ε)(1 - α)
      ~~~~~~~~   ~~~~~~~~~~~~~
        (가)          (나)
= 2 + ε - α
~~~
여기서 1, 2는 `3-4)메모리 접근 횟수`, <br>
ε은 `3-5)TLB 검색 소요 시간`, <br>
α는 `3-6)TLB 적중률`을 <br>
나타낸다.

(가) 부분은 TLB 적중이 `성공` 했을 경우이다. <br>
(나) 부분은 TLB 적중이 `실패` 했을 경우이다.

> (가) (TLB 성공으로 메모리 접근 1회 + TLB 탐색시간) * TLB 적중률 <br>
> (나) (TLB miss로 페이지 테이블에 접근 1번 + 실제 데이터에 접근 1번 + TLB 탐색시간) * TLB 실패율 이다.


#### 계층적 페이징

<img width="604" alt="스크린샷 2020-10-26 오전 7 19 25" src="https://user-images.githubusercontent.com/53321189/97120630-c0db6a80-175b-11eb-91ba-8671aba9cf77.png">

##### 4. 2단계 페이징 기법에서는 현재 사용되지 않는 주소공간(ex 코드에서 핵심연산 부분이 아닌, 예외처리 부분)에 대해서는 `외부` 페이지 테이블 항목을 `NULL`로 설정하여 대응되는 `내부` 페이지 테이블을 생성하지 않음으로써 1단계 페이징 기법보다 메모리 낭비를 줄일 수 있다. 


##### 5. n비트로 구분 가능한 서로 다른 위치의 개수는?
> 2^n 개


##### 6. 32비트 운영체제에서 페이지 하나의 크기는? 
> 4KB


##### 7. 내부 페이지 테이블은 2^10개의 항목을 가지고 있다. 2^10개 항목을 구분하기 위해 필요한 비트의 개수는?
>10비트


##### 8. 4KB는 2^12바이트이다. 바이트 단위의 오프셋을 표현하기 위한 비트의 개수는?
>12비트.


##### 9. 2단계 페이징에서 논리적 주소를 결정하는 P1, P2, d는 각각 몇 비트를 사용하는가?
>10비트,10비트,12비트


##### 10. N단계 페이징을 하면 메모리 접근 1번을 위해서 메모리 접근을 총 N+1번이나 해야한다. 그래도 N단계 페이징을 사용하는 이유가 있다면 그건 무엇일까요?
> TLB가 워낙 빨라서 TLB 적중률이 높으면 N단계 페이징을 해도 시간이 그렇게 오래 걸리지 않는다.
> 혹은, 메모리 공간을 줄여 공간적인 이득을 위해. *둘 다 쓰신 분 +10점!!*


##### 11. 다음은 4단계 페이징의 EAT이다. 

~~~
EAT = 0.98 * 120 + 0.02 * 520 = 128
	    ~~~~   ~~~   ~~~~   ~~~
	    (가)   (나)	  (다) 	(라)
~~~

각 항목이 의미하는 바를 아래 항목을 이용해 표현해보세요.

`α = TLB 적중률` `ε = TLB 탐색시간` `m = 메모리 접근 시간`

예시) 2m + ε * (α - 1)

(가) `α`<br>
(나) `m + ε`  ---------  TLB 성공시 TLB 탐색시간(20) + 실제 데이터에 대한 메모리 접근 시간(100)<br>
(다) `1 - α` ----------------- TLB miss율<br>
(라) `ε + 5m` ---------------- TLB miss시 TLB 탐색시간(20) + 4단계 접근 시간 (400) + 실제 데이터에 대한 메모리 접근 시간(100)


#### 12. 역페이지 테이블은 프로세스당 페이지 테이블을 하나만 두는 방법을 말한다. (X)
> 시스템 전체(system-wide)에 하나만 두는 방법이다. 

#### 13. 공유 코드의 특징 2가지를 적어보세요.
> 1. `읽기 전용`이어야 한다.
> 2. 공유하는 프로세스들 논리적 주소 공간에서 동일한 위치를 가져야 한다.(= `동일한 논리적 주소`를 가져야 한다)


![스크린샷 2020-10-26 오전 7 32 38](https://user-images.githubusercontent.com/53321189/97120885-c89c0e80-175d-11eb-9af9-b94ff613cbff.png)

- [메모리관리 III 0:24:35 설명 참고!](https://core.ewha.ac.kr/publicview/C0101020170508150536565534)


#### 14. 메모리 보호를 위해 존재하는 `보호 비트`는 각 페이지에 누가 접근할 수 있는지 접근 권한의 내용을 담고 있다. (X)
> 프로세스의 주소 공간은 다른 프로세스에 의해 접근될 수 없으므로 '누구'에 의해서는 설정할 필요가 없다. '어떤' 접근을 허용하는지만 저장하면 된다.

#### 15. 메모리 보호를 위해 존재하는 `유효-무효 비트`는 프로세스가 백킹스토어에 적재되어 있는 경우, 혹은 현재 사용하지 않는 주소 공간인 경우에 '무효(i)'로 설정된다. (O)




</div>
</details>
<br><br>

### 7-5 :fallen_leaf: 세그먼테이션 	　`kukim`

#### 보기를 이용해 아래의 괄호를 채우세요.

##### 보기
`physical unit(물리적인 단위)`,`logical unit(논리적인 단위)`, `길이가 동일`, `길이`, `페이징`, `세그먼테이션`, `짧은`, `보조 오프셋`, `세그먼트 정렬`, `os 스터디 꿀잼`

1. 세그먼테이션 기법은 메모리 공간을 `(     )`로 나눈 것을 뜻한다.
2.  페이징 기법은 모든 페이지의 `(     )` 하므로, 페이지 테이블의 항목에 기준점이라 할 수 있는 페이지 프레임 위치만 유지하고 있으면 된다. 하지만 세그먼테이션 기법에서는 세그먼트의 길이가 `(     )`하지 않다.
3.  세그먼테이션 기법은 페이징 기법과 유사하게 테이블을 사용하여 물리 메모리 주소에 접근한다. 페이징 테이블은 <페이지 번호, 오프셋>으로 구현되어 있고 세그먼트 테이블은  <세그먼트 번호, 오프셋>에 < `(     )` > 를 더하여 구현되어있다.
4. +a) 리눅스 OS의 프로세스 메모리 할당 기법은 `(     )` 기반으로 구현되어있다.

#### 세그먼테이션 기법 활용 예
- x86 리얼모드 (CS, DS, SS, ES로 세그먼트를 나누어 메모리 접근)
- 인텔의 x86으로 업그레이드(80286버전, CPU의 protection ring, 보호모드 추가)되면서 기존의 8086/80186 CPU칩셋이 돌아가지 않는 문제를 해결하기 위해 세그멘테이션 기법을 사용하여 과거의 CPU 버전을 세그먼트로 나누어, 메모리 접근함

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
#### 보기를 이용해 아래의 괄호를 채우세요.
##### 보기
`physical unit(물리적인 단위)`,`logical unit(논리적인 단위)`, `길이가 동일`, `길이`, `페이징`, `세그먼테이션`, `짧은`, `보조 오프셋`, `세그먼트 정렬`, `os 스터디 꿀잼`

1. 세그먼테이션 기법은 메모리 공간을 (`logical unit(논리적인 단위)`)로 나눈 것을 뜻한다.
2.  페이징 기법은 모든 페이지의 (`길이가 동일`) 하므로, 페이지 테이블의 항목에 기준점이라 할 수 있는 페이지 프레임 위치만 유지하고 있으면 된다. 하지만 세그먼테이션 기법에서는 세그먼트의 길이가 (`길이가 동일`)하지 않다.
3.  세그먼테이션 기법은 페이징 기법과 유사하게 테이블을 사용하여 물리 메모리 주소에 접근한다. 페이징 테이블은 <페이지 번호, 오프셋>으로 구현되어 있고 세그먼트 테이블은  <세그먼트 번호, 오프셋>에 < (`길이`) > 를 더하여 구현되어있다.
4. +a) 리눅스 OS의 프로세스 메모리 할당 기법은 (`페이징`) 기반으로 구현되어있다.

#### 세그먼테이션 기법 활용 예
- x86 리얼모드 (CS, DS, SS, ES로 세그먼트를 나누어 메모리 접근)
- 인텔의 x86으로 업그레이드(80286버전, CPU의 protection ring, 보호모드 추가)되면서 기존의 8086/80186 CPU칩셋이 돌아가지 않는 문제를 해결하기 위해 세그멘테이션 기법을 사용하여 과거의 CPU 버전을 세그먼트로 나누어, 메모리 접근함

</div>
</details>
<br><br>

### 7-6 :fallen_leaf: 페이지드 세그먼테이션 	　`gaekim`
 
1. 페이징 기법과 세그먼테이션 기법은 각각의 장단점을 갖고 있는데, `____ ______` 기법은 이들 두 기법의 장점만을 취하는 주소 변환 기법이다.
2. 페이지드 세그먼테이션 기법은 프로그램을 의미 단위의 `____`로 나눈다. 그리고 각 `____`를 다시 `___` 단위로 일정하게 나눈다.
3. 페이지드 세그먼테이션 기법은 하나의 세그먼트의 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 `내부조각 / 외부조각`의 문제점을 해결한다. 또한 동시에 `세그먼트 / 페이지` 단위로 프로세서 간의 공유나 프로세스 내의 접근 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해소한다. 
4. 페이지드 세그먼테이션 기법에서는 주소 변환을 위해 외부의 `세그먼트 / 페이지` 테이블과 내부의 `세그먼트 / 페이지` 테이블, 이렇게 두 단계의 테이블을 이용한다.


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
1. 페이징 기법과 세그먼테이션 기법은 각각의 장단점을 갖고 있는데, `페이지드 세그먼테이션` 기법은 이들 두 기법의 장점만을 취하는 주소 변환 기법이다.
2. 페이지드 세그먼테이션 기법은 프로그램을 의미 단위의 `세그먼트`로 나눈다. 그리고 각 `세그먼트`를 다시 `페이지` 단위로 일정하게 나눈다.  
   > 페이지드 세그먼테이션 기법에서 세그먼트의 길이는 **동일한 크기**를 갖는 페이지들의 집합으로 구성된다.  
3. 페이지드 세그먼테이션 기법은 하나의 세그먼트의 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 `외부조각`의 문제점을 해결한다. 또한 동시에 `세그먼트` 단위로 프로세서 간의 공유나 프로세스 내의 접근 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해소한다.  
   > 페이지드 세그먼테이션 기법은 세그먼테이션 기법의 외부조각 문제와 페이징 기법의 공유와 보호 문제를 보완해주는 기법이다.
4. 페이지드 세그먼테이션 기법에서는 주소 변환을 위해 외부의 `세그먼트` 테이블과 내부의 `페이지` 테이블, 이렇게 두 단계의 테이블을 이용한다.  
   > 하나의 세그먼트가 여러 개의 페이지로 구성되므로 **각 세그먼트마다 페이지 테이블을 가지는데**, 이는 **2단계 페이지 테이블과 유사한 구조이다.**

</div>
</details>
<br><br>
