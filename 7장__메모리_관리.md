
## 7장 메모리 관리

<br>

### 7-1 :fallen_leaf: 주소 바인딩　`secho`

1번.

`물리적 주소, 물리넷 주소, 논리적 주소, 논리적 메모리, 물리적 메모리, 엉기적 메모리`

`아가대리 프로그램`은 메모리에 적재되어 주소공간을 생성했다. 이 주소공간을 `___ __`라고 하며, `아가대리 프로그램`이 사용자 `쿠킴`에게 실행되기 위해서 `___ ___`에 올라가 있어야 하며 CPU인 `개킴`의 기계어 명령을 수행하기 위해  논리적 주소를 통해 메모리 참조를 하면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야한다.

<br>

2번.

주소 바인딩이란 무엇인지와 3가지 종류에 대해서 말씀해주세요.

<br>

3번

문제 : `한계 레지스터`없는 MMU기법에서 나올 수 있는 문제점과 이를 방지해주는`한계 레지스터, 기준레지스터`의 역할은 뭘까요?




<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

1번.

`물리적 주소, 물리넷 주소, 논리적 주소, 논리적 메모리, 물리적 메모리, 엉기적 메모리`

`아가대리 프로그램`은 메모리에 적재되어 주소공간을 생성했다. 이 주소공간을 `논리적 주소`라고 하며, `아가대리 프로그램`이 사용자 `쿠킴`에게 실행되기 위해서 `물리적 메모리`에 올라가 있어야 하며 CPU인 `개킴`의 기계어 명령을 수행하기 위해서  논리적 주소를 통해 메모리 참조를 하면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야한다.



2번.

주소 바인딩이란 무엇인지와 3가지 종류에 대해서 말씀해주세요.

프로세스의 논리적 주소 = 물리적 주소로 연결시키는 작업을 **주소 바인딩**이라 한다.

컴파일 타임 바인딩, 로드 타임 바인딩, 실행시간 바인딩

![image](https://user-images.githubusercontent.com/55486644/97109874-29552800-1719-11eb-9a32-d6eff02b22f7.png)

- 컴파일 타임 바인딩: 프로그램을 컴파일할 때 물리적 메모리주소가 결정됨 (물리적 메모리주소 === 논리적(프로그램 )메모리 주소) 
  - 프로그램 내 주소인 0번 10번 20번 ..의 논리적 주소가 물리적 주소로 그대로 결정됨
  - 이미 다른 프로세스에서 사용하고 있는 메모리주소가 있을 수 있기에 이 방법은 현재 거의 안씀 - 아두이노같은 경우에는 사용(한 프로그램만 돌아감)
- 로드 타임 바인딩 : 프로그램 **실행이 시작될 때** 물리적 주소가 결정
  - 프로그램 종료까지 물리적 메모리 위치 고정
  - 실행될 때마다 주소가 변경되므로 프로그램 내의 메모리 주소 전체를 어디에 로딩되는지에 따라 주소를 전부 다 바꿔주어야함. -> 메모리 로딩시간이 긺 -> 안씀
- 실행시간 바인딩 : 실행 이후, 메모리 주소가 변경될 수 있음
  - 기준, 한계, MMU 하드웨어의 지원으로 가능
  - load타임과 같은데  물리적 메모리에서 HW가 메모리 주소를 매핑시켜줌



3번

문제 : `한계 레지스터`없는 MMU기법에서 나올 수 있는 문제점과 이를 방지해주는`한계 레지스터, 기준레지스터`의 역할은 뭘까요?

- 기준 레지스터만 있을 때 해당 프로세스의 주소공간의 범위를 몰라 범위를 넘어서서 다른 곳으로 침범할 수 있는 `메모리보안`이 이루어지지 않아 치명적 결과가 발생할 수 있는데 프로세스의 크기를 담는 `한계 프로세스`를 통해 cpu가 요청한 프로세스의 논리적 주소값이 자신 프로세스의 크기보다 작은지 확인하여 방지할 수 있음.

</div>
</details>
<br><br>

### 7-2 :fallen_leaf: 메모리 관리와 관련된 용어	　`jehong`
 
문제 작성


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>


### 7-3 :fallen_leaf: 물리적 메모리의 할당 방식	　`taelee`
 
문제 작성


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>

### 7-4 :fallen_leaf: 페이징 기법	　`yeosong`
 
문제 작성


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>

### 7-5 :fallen_leaf: 세그먼테이션 	　`kukim`

#### 보기를 이용해 아래의 괄호를 채우세요.

##### 보기
`physical unit(물리적인 단위)`,`logical unit(논리적인 단위)`, `길이가 동일`, `길이`, `페이징`, `세그먼테이션`, `짧은`, `보조 오프셋`, `세그먼트 정렬`, `os 스터디 꿀잼`

1. 세그먼테이션 기법은 메모리 공간을 `(     )`로 나눈 것을 뜻한다.
2.  페이징 기법은 모든 페이지의 `(     )` 하므로, 페이지 테이블의 항목에 기준점이라 할 수 있는 페이지 프레임 위치만 유지하고 있으면 된다. 하지만 세그먼테이션 기법에서는 세그먼트의 길이가 `(     )`하지 않다.
3.  세그먼테이션 기법은 페이징 기법과 유사하게 테이블을 사용하여 물리 메모리 주소에 접근한다. 페이징 테이블은 <페이지 번호, 오프셋>으로 구현되어 있고 세그먼트 테이블은  <세그먼트 번호, 오프셋>에 < `(     )` > 를 더하여 구현되어있다.
4. +a) 리눅스 OS의 프로세스 메모리 할당 기법은 `(     )` 기반으로 구현되어있다.

#### 세그먼테이션 기법 활용 예
- x86 리얼모드 (CS, DS, SS, ES로 세그먼트를 나누어 메모리 접근)
- 인텔의 x86으로 업그레이드(80286버전, CPU의 protection ring, 보호모드 추가)되면서 기존의 8086/80186 CPU칩셋이 돌아가지 않는 문제를 해결하기 위해 세그멘테이션 기법을 사용하여 과거의 CPU 버전을 세그먼트로 나누어, 메모리 접근함

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
#### 보기를 이용해 아래의 괄호를 채우세요.
##### 보기
`physical unit(물리적인 단위)`,`logical unit(논리적인 단위)`, `길이가 동일`, `길이`, `페이징`, `세그먼테이션`, `짧은`, `보조 오프셋`, `세그먼트 정렬`, `os 스터디 꿀잼`

1. 세그먼테이션 기법은 메모리 공간을 (`logical unit(논리적인 단위)`)로 나눈 것을 뜻한다.
2.  페이징 기법은 모든 페이지의 (`길이가 동일`) 하므로, 페이지 테이블의 항목에 기준점이라 할 수 있는 페이지 프레임 위치만 유지하고 있으면 된다. 하지만 세그먼테이션 기법에서는 세그먼트의 길이가 (`길이가 동일`)하지 않다.
3.  세그먼테이션 기법은 페이징 기법과 유사하게 테이블을 사용하여 물리 메모리 주소에 접근한다. 페이징 테이블은 <페이지 번호, 오프셋>으로 구현되어 있고 세그먼트 테이블은  <세그먼트 번호, 오프셋>에 < (`길이`) > 를 더하여 구현되어있다.
4. +a) 리눅스 OS의 프로세스 메모리 할당 기법은 (`페이징`) 기반으로 구현되어있다.

#### 세그먼테이션 기법 활용 예
- x86 리얼모드 (CS, DS, SS, ES로 세그먼트를 나누어 메모리 접근)
- 인텔의 x86으로 업그레이드(80286버전, CPU의 protection ring, 보호모드 추가)되면서 기존의 8086/80186 CPU칩셋이 돌아가지 않는 문제를 해결하기 위해 세그멘테이션 기법을 사용하여 과거의 CPU 버전을 세그먼트로 나누어, 메모리 접근함

</div>
</details>
<br><br>

### 7-6 :fallen_leaf: 페이지드 세그먼테이션 	　`gaekim`
 
문제 작성


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
답 작성 

</div>
</details>
<br><br>
