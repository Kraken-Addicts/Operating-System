## 보충3__교착상태

<br>

### 보충3.1 :fallen_leaf:  시스템 모델 `secho`
0번.
다음은 교착상태에 대한 설명입니다 빈칸을 채워주세요
`충분한` `한정된`
교착상태란 프로세스에게 `___`자원이 분배되었을 때 프로세스들이 자원의 부족으로 더이상 실행할 수 없어 끝낼수도 없으며, 자원이 프로세스에게 묶여 다른 작업을 시작하는 것도 불가능한 상태를 말한다.
1번.
프로세스는 다음 순서로만 자원을 사용할 수 있습니다. 간단하게 채워주세요
1. 요청 :  
2. 사용 :
3. 방출 : 

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

0번.
다음은 교착상태에 대한 설명입니다 빈칸을 채워주세요
`충분한` `한정된`
교착상태란 프로세스에게 `한정된`자원이 분배되었을 때 프로세스들이 자원의 부족으로 더이상 실행할 수 없어 끝낼수도 없으며, 자원이 프로세스에게 묶여 다른 작업을 시작하는 것도 불가능한 상태를 말한다.

1번.
프로세스는 다음 순서로만 자원을 사용할 수 있습니다. 간단하게 채워주세요
1. 요청 :  쓰레드의 자원 요청, 요청이 혀용되지 않으면 대기
2. 사용 : 자신의 임계구역에 접근해 작업을 수행함
3. 방출 :  자원 방출



</div>
</details>
<br><br>

<br>

### 보충3.2 :fallen_leaf:  다중 스레드 응용에서의 교착상태　`jehong`

**문제 1**

다음 코드를 보고 질문에 답하세요. (필요한 경우 보기를 참고하세요)

```c
//mutex 락 생성
pthread_mutex_t first_mutex;
pthread_mutex_t second_mutex;

//mutex 락 초기화
pthred_mutex_init(&first_mutex,NULL);
pthred_mutex_init(&second_mutex,NULL);

//thread_one
void *do_work_one(void *param)
{
  pthread_mutex_lock(&first_mutex);
  pthread_mutex_lock(&second_mutex);
  /**
   * Do some work
   */
  pthred_mutex_unlock(&second_mutex);
  pthred_mutex_unlock(&first_mutex);
}

//thread_two
void *do_work_two(void *param)
{
  pthread_mutex_lock(&second_mutex);
  pthread_mutex_lock(&first_mutex);
  /**
   * Do some work
   */
  pthred_mutex_unlock(&first_mutex);
  pthred_mutex_unlock(&second_mutex);
}
```

> **<보기>**
>
> `first_mutex`, `second_mutex`
>
> `1) first_mutex, 2) second_mutex`
>
> `1) second_mutex, 2) first_mutex`



1. 위 코드에서 thread_one은 `_________________________` 순서로 mutex 락을 획득하려고 하고 동시에 thread_two는 `_________________________` 순서로 mutex 락을 획득하려고 한다.

   

2. thread_one이 `____________`를 획득하고 thread_two가 `____________`를 획득하면 교착 상태가 가능하다.

   

3. 위 코드에서 교착 상태가 발생하지 않는 경우는 어떤 경우인가요?



**문제 2**

1. 다음 코드가 라이브락으로 이어질 수 있도록 (A), (B), (C)를 채워주세요.

   > **<보기>**
   >
   > `done`, `True`, `False`, `first_mutex`, `second_mutex`

   ```c
   //thread_one
   void *do_work_one(void *param)
   {
   	int done = 0;
     
     while (!👉👉🏻👉🏼👉🏽👉🏾👉🏿(A)👈🏿👈🏾👈🏽👈🏼👈🏻👈) {
       pthread_mutex_lock(&first_mutex);
       if (pthread_mutex_trylock(&👉👉🏻👉🏼👉🏽👉🏾👉🏿(B)👈🏿👈🏾👈🏽👈🏼👈🏻👈)) {
         /**
    		   * Do some work
          */
         pthred_mutex_unlock(&second_mutex);
         pthred_mutex_unlock(&first_mutex);
         done = 1;
       }
       else
         pthread_mutex_unlock(&first_mutex);
     }
     pthread_exit(0);
   }
   
   //thread_two
   void *do_work_two(void *param)
   {
   	int done = 0;
     
     while (!👉👉🏻👉🏼👉🏽👉🏾👉🏿(A)👈🏿👈🏾👈🏽👈🏼👈🏻👈) {
       pthread_mutex_lock(&second_mutex);
       if (pthread_mutex_trylock(&👉👉🏻👉🏼👉🏽👉🏾👉🏿(C)👈🏿👈🏾👈🏽👈🏼👈🏻👈)) {
         /**
    		   * Do some work
          */
         pthred_mutex_unlock(&first_mutex);
         pthred_mutex_unlock(&second_mutex);
         done = 1;
       }
       else
         pthread_mutex_unlock(&second_mutex);
     }
     pthread_exit(0);
   }
   ```





<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

**문제 1**

다음 코드를 보고 질문에 답하세요. (필요한 경우 보기를 참고하세요)

```c
//mutex 락 생성
pthread_mutex_t first_mutex;
pthread_mutex_t second_mutex;

//mutex 락 초기화
pthred_mutex_init(&first_mutex,NULL);
pthred_mutex_init(&second_mutex,NULL);

//thread_one
void *do_work_one(void *param)
{
  pthread_mutex_lock(&first_mutex);
  pthread_mutex_lock(&second_mutex);
  /**
   * Do some work
   */
  pthred_mutex_unlock(&second_mutex);
  pthred_mutex_unlock(&first_mutex);
}

//thread_two
void *do_work_two(void *param)
{
  pthread_mutex_lock(&second_mutex);
  pthread_mutex_lock(&first_mutex);
  /**
   * Do some work
   */
  pthred_mutex_unlock(&first_mutex);
  pthred_mutex_unlock(&second_mutex);
}
```

> **<보기>**
>
> `first_mutex`, `second_mutex`
>
> `1) first_mutex, 2) second_mutex`
>
> `1) second_mutex, 2) first_mutex`



1. 위 코드에서 thread_one은 `1) first_mutex, 2) second_mutex` 순서로 mutex 락을 획득하려고 하고 동시에 thread_two는 `1) second_mutex, 2) first_mutex` 순서로 mutex 락을 획득하려고 한다.

   

2. thread_one이 `first_mutex`를 획득하고 thread_two가 `second_mutex`를 획득하면 교착 상태가 가능하다.

   

3. 위 코드에서 교착 상태가 발생하지 않는 경우는 어떤 경우인가요?

   > **답**
   >
   > thread_two가 락을 획득하려고 시도하기 전에 **thread_one이** first_mutex와 second_mutex를 **획득하고 방출**할 수 있다면 교착 상태는 발생하지 않는다.



**문제 2**

1. 다음 코드가 라이브락으로 이어질 수 있도록 (A), (B), (C)를 채워주세요.

   > **<보기>**
   >
   > `done`, `True`, `False`, `first_mutex`, `second_mutex`

   > **답**
   >
   > (A) done
   >
   > (B) second_mutex
   >
   > (C) first_mutex

   ```c
   //thread_one
   void *do_work_one(void *param)
   {
   	int done = 0;
     
     while (!👉👉🏻👉🏼👉🏽👉🏾👉🏿(A)done👈🏿👈🏾👈🏽👈🏼👈🏻👈) {
       pthread_mutex_lock(&first_mutex);
       if (pthread_mutex_trylock(&👉👉🏻👉🏼👉🏽👉🏾👉🏿(B)second_mutex👈🏿👈🏾👈🏽👈🏼👈🏻👈)) {
         /**
    		   * Do some work
          */
         pthred_mutex_unlock(&second_mutex);
         pthred_mutex_unlock(&first_mutex);
         done = 1;
       }
       else
         pthread_mutex_unlock(&first_mutex);
     }
     pthread_exit(0);
   }
   
   //thread_two
   void *do_work_two(void *param)
   {
   	int done = 0;
     
     while (!👉👉🏻👉🏼👉🏽👉🏾👉🏿(A)done👈🏿👈🏾👈🏽👈🏼👈🏻👈) {
       pthread_mutex_lock(&second_mutex);
       if (pthread_mutex_trylock(&👉👉🏻👉🏼👉🏽👉🏾👉🏿(C)first_mutex👈🏿👈🏾👈🏽👈🏼👈🏻👈)) {
         /**
    		   * Do some work
          */
         pthred_mutex_unlock(&first_mutex);
         pthred_mutex_unlock(&second_mutex);
         done = 1;
       }
       else
         pthread_mutex_unlock(&second_mutex);
     }
     pthread_exit(0);
   }
   ```



</div>
</details>
<br><br>

<br>

### 보충3.3 :fallen_leaf:  교착상태 특성 `taelee`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>



### 보충3.4 :fallen_leaf:  교착상태 처리 방법 `yeosong`

#### 1. 교착 상태 문제를 처리하는 4가지 방법 중 하나인 "Deadlock Ignorance 교착상태 무시(교착 상태가 시스템에서 절대 발생하지 않는 척하기" 는 Windows, Linux가 사용하는 방법이다. `(O/X)` 

#### 2. 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구하여, 스레드가 기다려야 할지 아닐지를 결정하는 방식은 교착상태 `회피avoidence / 예방prevention` 방식이다.

#### 3. 상호배제, 점유하며 대기, 비선점, 순환 대기 4가지의 필요조건 중 적어도 하나가 성립하지 않도록 보장하는 방식은 교착상태 `회피avoidence / 예방prevention` 방식이다.

#### 4. Deadlock Detection and recovery는 데드락(교착상태) 발생은 허용하되 그에 대한 감지Detection 루틴을 두어 발견시 회복시키는 방법이다. `(O/X)`

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### 1. 교착 상태 문제를 처리하는 4가지 방법 중 하나인 "Deadlock Ignorance 교착상태 무시(교착 상태가 시스템에서 절대 발생하지 않는 척하기" 는 Windows, Linux가 사용하는 방법이다.`(O)` 
> O. 교착 상태가 드물게 발생하고, 무시가 다른 처리 방법과 비교해 비용이 적게 든다고 판단될 경우 이런 선택을 내릴 수도 있다.

#### 2. 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구하여, 스레드가 기다려야 할지 아닐지를 결정하는 방식은 교착상태 `회피avoidence` 방식이다.

#### 3. 상호배제, 점유하며 대기, 비선점, 순환 대기 4가지의 필요조건 중 적어도 하나가 성립하지 않도록 보장하는 방식은 교착상태 `예방prevention` 방식이다.

#### 4. Deadlock Detection and recovery는 데드락(교착상태) 발생은 허용하되 그에 대한 감지Detection 루틴을 두어 발견시 회복시키는 방법이다. `(O)`


</div>
</details>
<br><br>

### 보충3.5 :fallen_leaf:  교착상태 예방 `kukim`

교착 상태가 발생하는 조건은 앞 8.3에서 살펴본 4가지 필요 조건이 있습니다.  
이 4가지 조건은 무엇이었나요?

<details>
<summary> <b> :page_facing_up: 4가지 </b>  </summary>
<div markdown="1">
  
네! 바로  
Mutual Exclusion(상호배제), Hold & Wait(점유 대기), No Preemption(비선점), Circular Wait(순환 대기) 입니다.  

</div>
</details>
<br><br>

교착상태에 빠지는 조건을 알았으니 빠지지 않으려면 4가지 필요조건과 반대(!(필요조건))되면 됩니다
그 방법은 무엇일까요? 보기를 참고하여 짝지어 주세요!

```
[보기]
1. 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.
2. 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고있는 자원을 모두 반납하고 요구한 자원을 사용하기 위해 대기한다.
3. 자원에 교유한 번호를 할당하고, 프로세스에게 자원의 번호 순서대로 자원을 요구하라고 한다.
4. 프로세스가 실행되기 전에 필요한 모든 자원을 할당한다.
```
- 정답
  - 상호배제 - `  `
  - 점유 대기 - `  `
  - 비선점 - `  `
  - 순환대기 - `  `

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

교착 상태가 발생하는 조건은 앞 8.3에서 살펴본 4가지 필요 조건이 있습니다.  
이 4가지 조건은 무엇이었나요?

<details>
<summary> <b> :page_facing_up: 4가지 </b>  </summary>
<div markdown="1">
  
네! 바로  
Mutual Exclusion(상호배제), Hold & Wait(점유 대기), No Preemption(비선점), Circular Wait(순환 대기) 입니다.  

</div>
</details>
<br><br>

교착상태에 빠지는 조건을 알았으니 빠지지 않으려면 4가지 필요조건과 반대(!(필요조건))되면 됩니다
그 방법은 무엇일까요? 보기를 참고하여 짝지어 주세요!

```
[보기]
1. 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.
2. 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고있는 자원을 모두 반납하고 요구한 자원을 사용하기 위해 대기한다.
3. 자원에 교유한 번호를 할당하고, 프로세스에게 자원의 번호 순서대로 자원을 요구하라고 한다.
4. 프로세스가 실행되기 전에 필요한 모든 자원을 할당한다.
```
- 정답
  - 상호배제 - 1 
  - 점유 대기 - 4
  - 비선점 - 2
  - 순환대기 - 3


</div>
</details>
<br><br>

### 보충3.6 :fallen_leaf:  교착상태 회피 `mihykim`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

