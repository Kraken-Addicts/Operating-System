
## 4장 프로그램의 구조와 실행

<br>

### 4-1 :fallen_leaf: 프로그램의 구조와 인터럽트　`mihykim`
 
#### 문제1. 프로그램의 구조
- 보기에서 알맞은 단어를 골라 빈 칸을 채워주세요 (보기 중 택 1)
  ```
  한숨, 함수, 명명(naming), 명령(instruction), 띠로리, 메모리
  ```
  - 컴퓨터 프로그램은 어떠한 프로그래밍 언어로 작성되었던 그 내부구조는 `ㅇㅇ`들로 구성된다.
  - 프로그램이 CPU에서 `ㅇㅇ`을 수행하려면, 이를 담고 있는 프로그램의 주소공간이 `ㅇㅇㅇ`에 올라가 있어야 한다.
  - 이때 프로그램의 주소공간은 크게 코드/데이터/스택으로 구분된다.
<br>

#### 문제2. 주소공간의 구분
- 다음 그림을 참조하여 빈 칸에 들어갈 적절한 주소영역의 이름을 적어주세요 (단답형) <p align="center"><img src="https://user-images.githubusercontent.com/60066472/95650462-d5deb980-0b1e-11eb-998c-1cce69cd4b28.png" width="100"></p>
  - 전역변수 등 프로그램이 사용하는 데이터를 저장하는 부분 : `　　　영역`
  - 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령형태로 변환되어 저장되는 부분 : `　　　영역`
  - 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는데 사용되는 공간 : `　　　영역`
<br>

#### 문제3. 스택 vs 큐
- 다음 설명을 참고하여, 문제상황에 더 어울리는 자료구조를 골라주세요 (양자택일)
  ```
  ▶ 스택(stack) ◀ 은 데이터의 삽입과 삭제가 한쪽 방향에서만 일어나는 자료구조입니다.
  '쌓아올린 더미'라는 뜻이기도 합니다.
  
  가장 나중에 삽입된 데이터가 가장 먼저 삭제되어,
  선입후출(FILO First-In Last-Out) 또는 후입선출(LIFO Last-In First-Out) 원칙을 따릅니다.
  ```
<p align="center"><img src="https://user-images.githubusercontent.com/60066472/95649910-323fda00-0b1b-11eb-8b46-52ebf004e76a.png" width="250"></p>

  ```
  ▶ 큐(queue) ◀ 는 한쪽에서는 데이터 삽입만 반대쪽에서는 데이터 삭제만 일어나는 자료구조입니다.
  '일렬로 늘어선 사람들로 이루어진 줄'이라는 뜻이기도 합니다.
  
  가장 먼저 삽입된 데이터가 가장 먼저 삭제되어,
  선입선출(FIFO First-In First-Out) 원칙을 따릅니다.
  ```
<p align="center"><img src="https://user-images.githubusercontent.com/60066472/95649908-2f44e980-0b1b-11eb-93c3-8240f0ab31c9.png" width="500"></p>

  - 문제상황
    - 선반에서 쌓여있는 접시 꺼내기 : `스택 / 큐`
    - 프린터에 보내진 출력 작업 : `스택 / 큐`
    - 주기억장치(main memory)나 레지스터(register)의 일부를 할당하여 사용하는 임시기억장치(데이터를 일시적으로 겹쳐 쌓아두었다가 필요할 때 꺼내서 사용) : `스택 / 큐`
    - 문서 프로그램에서 실행취소(ctrl+z) : `스택 / 큐`
    - 은행의 번호표 시스템 : `스택 / 큐`
    - C언어에서 지역변수, 매개변수가 저장되는 메모리(변수 선언시 할당되고 함수 종료 시 자동으로 해제되는 자동메모리) : `스택 / 큐`
    - 운영체제의 작업큐(버퍼큐 및 스케줄링큐) : `스택 / 큐`
    - 편의점/마켓의 제품진열법 : `스택 / 큐`
    - 브라우저에서 뒤로가기 : `스택 / 큐`
    - 일방 통행도로에서 교통신호를 기다리는 자동차 : `스택 / 큐`
<br>

#### 문제4. 함수 호출 vs 인터럽트 동작
- 아래의 설명을 읽고 빈 칸에 들어갈 적절한 단어를 적어주세요. (단답식)
  - 함수의 호출과 인터럽트의 동작은 그 원리가 서로 비슷합니다.
  - 함수가 호출될 경우, CPU는 순차적으로 명령을 수행하다가 호출된 함수의 위치로 점프해서 새로운 위치의 명령을 실행합니다. 호출된 함수를 모두 수행하고 나면, 원래 함수가 수행되던 위치로 돌아가는데 이 복귀 주소는 `ㅇㅇ ㅇㅇ`에 저장되어 있습니다.
  - 인터럽트가 발생하면 운영체제 내부 코드인 인터럽트 처리루틴으로 넘어가서 인터럽트 처리합니다. 인터럽트를 처리하고 나면, 원래 수행하던 일을 재개하는데 이 주소는 `ㅇㅇㅇㅇ ㅇㅇㅇㅇ(ㅇㅇㅇ)`에 저장되어 있습니다.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
#### 문제1. 프로그램의 구조
- 보기에서 알맞은 단어를 골라 빈 칸을 채워주세요 (택 1)
  - 컴퓨터 프로그램은 어떠한 프로그래밍 언어로 작성되었던 그 내부구조는 `함수`들로 구성된다.
  - 프로그램이 CPU에서 `명령(instruction)`을 수행하려면, 이를 담고 있는 프로그램의 주소공간이 `메모리`에 올라가 있어야 한다.
  - 이때 프로그램의 주소공간은 크게 코드/데이터/스택으로 구분된다.

#### 문제2. 주소공간의 구분
- 다음 그림을 참조하여 빈 칸에 들어갈 적절한 주소영역의 이름을 적어주세요 (단답형)
  - 전역변수 등 프로그램이 사용하는 데이터를 저장하는 부분 : `데이터영역`
  - 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령형태로 변환되어 저장되는 부분 : `코드영역`
  - 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는데 사용되는 공간 : `스택영역`

#### 문제3. 스택 vs 큐
- 다음 설명을 참고하여, 스택과 큐 둘 중 주어지는 상황에 더 적절한 것을 골라주세요 (택 1)
  - 문제상황
    - 선반에서 쌓여있는 접시 꺼내기 : `스택`
    - 프린터에 보내진 출력 작업 : `큐`
    - 주기억장치(main memory)나 레지스터(register)의 일부를 할당하여 사용하는 임시기억장치(데이터를 일시적으로 겹쳐 쌓아두었다가 필요할 때 꺼내서 사용) : `스택`
    - 문서 프로그램에서 실행취소(ctrl+z) : `스택`
    - 은행의 번호표 시스템 : `큐`
    - C언어에서 지역변수, 매개변수가 저장되는 메모리(변수 선언시 할당되고 함수 종료 시 자동으로 해제되는 자동메모리) : `스택`
    - 운영체제의 작업큐(버퍼큐 및 스케줄링큐) : `큐`
    - 편의점/마켓의 제품진열법 : `큐`
    - 브라우저에서 뒤로가기 : `스택`
    - 일방 통행도로에서 교통신호를 기다리는 자동차 : `큐`

#### 문제4. 함수 호출 vs 인터럽트 동작
- 아래의 설명을 읽고 빈 칸에 들어갈 적절한 단어를 적어주세요. (단답식)
  - 함수의 호출과 인터럽트의 동작은 그 원리가 서로 비슷합니다.
  - 함수가 호출될 경우, CPU는 순차적으로 명령을 수행하다가 호출된 함수의 위치로 점프해서 새로운 위치의 명령을 실행합니다. 호출된 함수를 모두 수행하고 나면, 원래 함수가 수행되던 위치로 돌아가는데 이 복귀 주소는 `스택 영역`에 저장되어 있습니다.
  - 인터럽트가 발생하면 운영체제 내부 코드인 인터럽트 처리루틴으로 넘어가서 인터럽트 처리합니다. 인터럽트를 처리하고 나면, 원래 수행하던 일을 재개하는데 이 주소는 `프로세스 제어블록(PCB)`에 저장되어 있습니다.

</div>
</details>
<br><br>

### 4-2 :fallen_leaf: 컴퓨터 시스템의 작동 개요	　`daelee`
 
1. 보기를 참고해 빈칸을 채워주세요.

   ```
   로컬 버퍼, 커널, 타이머, DMA 컨트롤러, 입출력 컨트롤러, 사용자, 모드비트, 로컬 버터, 프로그램 카운터, 유저, 디스크
   ```

   - CPU는 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 실행할 뿐이다. 이때 CPU가 수행해야 할 메모리 주소를 담고있는 레지스터를 `________`라고 부른다. 



   -  컴퓨터를 구성하는 하드웨어로는 CPU와 메모리가 있고, 이 밖에 각 입출력 장치와 이들 장치를 전담하는 작은 CPU와 메모리가 있다. 입출력 장치별로 존재하는 이들을 각각 `_______`와 `____` 라고 부른다. 

    

   - 프로그램 카운터가 운영체제가 존재하는 메모리 주소를 가리키고 있다면 이 경우 CPU가 `____모드` 에서 수행 중이라고 이야기한다. 반대로 프로그램 카운터가 유저 어플리케이션이 존재하는 메모리 위치를 가리키고 있다면 `____모드`에서 CPU가 수행되고 있다고 이야기한다.

2. `커널 모드`에서는 모오든 시스템 메모리와 모오오든 CPU 인스트럭션에 접근이 허가된다. (O / X)



3. `시스템 콜(system call)`이 발생하는 상황 한 가지를 예로 들어보세요.

  


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
1. 보기를 참고해 빈칸을 채워주세요.

   ```
   로컬 버퍼, 커널, 타이머, DMA 컨트롤러, 입출력 컨트롤러, 사용자, 모드비트, 로컬 버터, 프로그램 카운터, 유저, 디스크
   ```

   - CPU는 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 실행할 뿐이다. 이때 CPU가 수행해야 할 메모리 주소를 담고있는 레지스터를 `________`라고 부른다. 

     > 정답 : 프로그램 카운터
     >
     > CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리하게 된다.

   -  컴퓨터를 구성하는 하드웨어로는 CPU와 메모리가 있고, 이 밖에 각 입출력 장치와 이들 장치를 전담하는 작은 CPU와 메모리가 있다. 입출력 장치별로 존재하는 이들을 각각 `_______`와 `____` 라고 부른다. 

     > 정답 : 입출력 컨트롤러, 로컬 버퍼
     >
     > 컴퓨터 시스템의 동작은 CPU에 의해서만 이루어지는 것이 아니다. 프로그램이 수행되는 중에 디스크에서 파일을 읽어오기도 하고 키보드로부터 입력을 받거나 처리 결과를 화면에 출력하기도 한다.

   - 프로그램 카운터가 운영체제가 존재하는 메모리 주소를 가리키고 있다면 이 경우 CPU가 `____모드` 에서 수행 중이라고 이야기한다. 반대로 프로그램 카운터가 유저 어플리케이션이 존재하는 메모리 위치를 가리키고 있다면 `____모드`에서 CPU가 수행되고 있다고 이야기한다.

2. `커널 모드`에서는 모오든 시스템 메모리와 모오오든 CPU 인스트럭션에 접근이 허가된다. (O / X)

   > 정답 : O
   >
   > CPU가 수행하는 명령에는 일반명령과 특권명령이 있다. 컴퓨터 시스템에서는 보안이 필요한 특권명령은 항상 운영체제만이, 즉 커널모드에서만 수행할 수 있도록 제한하고 있다.

3. `시스템 콜(system call)`이 발생하는 상황 한 가지를 예로 들어보세요.

   > 정답 :
   >
   > 유저 어플리케이션이 디스크에 접근해 파일로부터 데이터를 읽거나, 읽은 데이터를 화면에 출력하려면 일반명령 외에 특권명령의 수행이 필요하다. 유저 어플리케이션은 스스로 특권명령을 수행할 수 없으므로 운영체제에게 **시스템 콜**을 해 유저모드에서 커널모드로 전환해 작업을 수행한다.

</div>
</details>
<br><br>


### 4-3 :fallen_leaf: 프로그램의 실행	　`secho`

1번

실행파일이 메모리에 적재되거나 CPU를 할당받고 명령을 수행하고있는 상태를 프로그램이 `__`되고 있다 라고한다.

<br>

2번

`데이터, 큐, 스택, 코드, 스왑, 물리적 메모리, 상대적 메모리, 가상 메모리`

프로세스의 주소공간은 `__`, `___`, `__`등으로 구성되는데 프로그램마다 별도로 갖는 이러한 주소공간을 `_____` 또는 `______`라고 부른다.

 `___`영역에는  프로세스의 상태, CPU 사용정보 등을 유지하기 위한 PCB를 두고 있다.

<br>

3번

커널역시 이와 같이 별도의 주소공간을 갖고 있는데 커널의 `코드`는 주로 CPU, 메모리 등의 자원관리를 위한 부분, 시스템 콜, 인터럽트를 처리하기 위한 부분을 포함한다.

 `데이터`영역에는  프로세스의 상태, CPU 사용정보 등을 유지하기 위한 PCB를 두고 있다.

<br>


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

답지

1번

실행파일이 메모리에 적재되거나 CPU를 할당받고 명령을 수행하고있는 상태를 프로그램이 `실행`되고 있다 라고한다.

2번

`데이터, 큐, 스택, 코드, 스왑, 물리적 메모리, 상대적 메모리, 가상 메모리`

프로세스의 주소공간은 `코드`, `데이터`, `스택`등으로 구성되는데 프로그램마다 별도로 갖는 이러한 주소공간을 `가상메모리` 또는 `논리적 메모리`라고 부른다.

3번

커널역시 이와 같이 별도의 주소공간을 갖고 있는데 커널의 `코드`는 주로 CPU, 메모리 등의 자원관리를 위한 부분, 시스템 콜, 인터럽트를 처리하기 위한 부분을 포함한다.

 `데이터`영역에는  프로세스의 상태, CPU 사용정보 등을 유지하기 위한 PCB를 두고 있다.

</div>
</details>
<br><br>


### 4-4 :fallen_leaf: 사용자 프로그램이 사용하는 함수	　`jehong`
 




1. 다음 보기에서 골라 빈칸을 알맞게 채우세요

   >**보기**
   >
   >`운영체제에 CPU를 넘겨서 실행`, `사용자 정의 함수`, `라이브러리 함수`, `사용자 프로그램의 코드 영역`, `커널함수`, `taeleebabo()`, `kido_calm_down()`, `sin()`, `printf()`, `read()`, `write()`, `커널의 스택`, `사용자 프로그램 내에 존재하는 코드 실행`, `운영체제 커널의 주소 공간`

|                              |            `_______a_______`            |                    `_______b_______`                    |          `_______c_______`           |
| :--------------------------: | :-------------------------------------: | :-----------------------------------------------------: | :----------------------------------: |
|           **정의**           |   프로그래머 본인이 직접 작성한 함수    | 이미 누군가 작성해놓은 함수를 호출만 하여 사용하는 함수 |      커널의 코드에 정의된 함수       |
|           **종류**           |                    -                    |                            -                            |  시스템 콜 함수, 인터럽트 처리 함수  |
|        **저장 공간**         |            `_______d_______`            |               `_______d_______`               |          `_______e_______`           |
| **함수호출시 사용하는 스택** | 사용자 프로그램의 주소 공간에 있는 스택 |         사용자 프로그램의 주소 공간에 있는 스택         |          `_______f_______`           |
|        **함수호출시 실행 과정**         |            `_______g_______`            |         `_______g_______`         |          `_______h_______`           |
|         **해당 함수**         |  `_______i_______`, `_______j_______`   |          `_______k_______`, `_______l_______`           | `_______m_______`, `_______n_______` |






<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
 1. 다음 보기에서 골라 빈칸을 알맞게 채우세요

   >**보기**
   >
   >`운영체제에 CPU를 넘겨서 실행`, `사용자 정의 함수`, `라이브러리 함수`, `사용자 프로그램의 코드 영역`, `커널함수`, `taeleebabo()`, `kido_calm_down()`, `sin()`, `printf()`, `read()`, `write()`, `커널의 스택`, `사용자 프로그램 내에 존재하는 코드 실행`

|                              |            `사용자 정의 함수`             |                    `라이브러리 함수`                    |             `커널함수`             |
| :--------------------------: | :---------------------------------------: | :-----------------------------------------------------: | :--------------------------------: |
|           **정의**           |    프로그래머 본인이 직접 작성한 함수     | 이미 누군가 작성해놓은 함수를 호출만 하여 사용하는 함수 |     커널의 코드에 정의된 함수      |
|           **종류**           |                     -                     |                            -                            | 시스템 콜 함수, 인터럽트 처리 함수 |
|        **저장 공간**         |       `사용자 프로그램의 코드 영역`       |               사용자 프로그램의 코드 영역               |    `운영체제 커널의 주소 공간`     |
| **함수호출시 사용하는 스택** |  사용자 프로그램의 주소 공간에 있는 스택  |         사용자 프로그램의 주소 공간에 있는 스택         |           `커널의 스택`            |
|        **함수호출시 실행 과정**         | `사용자 프로그램 내에 존재하는 코드 실행` |         사용자 프로그램 내에 존재하는 코드 실행         |   `운영체제에 CPU를 넘겨서 실행`   |
|         **해당 함수**         |    `taeleebabo()`, `kido_calm_down()`     |                   `sin()`, `printf()`                   |        `read()`, `write()`         |





</div>
</details>
<br><br>


### 4-5 :fallen_leaf: 인터럽트	　`taelee`

1. 원칙적으로 인터럽트를 처리중에 또 다른 인터럽트가 발생하는 것을 허용하지 않는다. 그 이유는?(주관식)
2. 그럼에도 불구하고 인터럽트 처리중에 또 다른 인터럽트를 처리하는 경우가 있다고 한다. 언제 그럴까?(주관식)
3. A 인터럽트 처리중에 우선 순위가 높은 B 인터럽트가 발생해서 CPU는 B 인터럽트를 처리하러 갔다가 복귀 하려고 한다. CPU는 어디로 복귀해야 하는가?
     1. B 인터럽트를 발생시킨 코드로 복귀해서 B 인터럽트 처리 결과를 바탕으로 그 이후 부분을 수행하러 간다.
     2. B 인터럽트가 발생되기 직전에 처리하던 A 인터럽트를 처리하러 간다.
     3. 여자친구를 만나러 동탄에 간다.




<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

1. 원칙적으로 인터럽트를 처리중에 또 다른 인터럽트가 발생하는 것을 허용하지 않는다. 그 이유는?(주관식)

     **처리중이던 데이터를 그 다음 인터럽트가 변경시킨다면 데이터의 일관성이 유지될 수 없다.** 

2. 그럼에도 불구하고 인터럽트 처리중에 또 다른 인터럽트를 처리하는 경우가 있다고 한다. 언제 그럴까?(주관식)

     **더 시급하거나 CPU를 당장 사용해야 하는 일이 발생했을 때**

3. A 인터럽트 처리중에 우선 순위가 높은 B 인터럽트가 발생해서 CPU는 B 인터럽트를 처리하러 갔다가 복귀 하려고 한다. CPU는 어디로 복귀해야 하는가? **정답 2번**
     1. B 인터럽트를 발생시킨 코드로 복귀해서 B 인터럽트 처리 결과를 바탕으로 그 이후 부분을 수행하러 간다.
     2. **B 인터럽트가 발생되기 직전에 처리하던 A 인터럽트를 처리하러 간다.**
     3. 여자친구를 만나러 동탄에 간다.

</div>
</details>
<br><br>




### 4-6 :fallen_leaf: 시스템 콜	　`yeosong`
 
#### 1. 보기에서 알맞은 말을 골라 문장을 완성하세요.


`사용자 정의 함수` `시스템 콜 함수` `라이브러리 함수` `ft_print의 주소 공간` `커널의 주소 공간`


- 뛰어난 개발자인 `hylee`가 만든 프로그램 `ft_print`에서 `va_start()`는 `________`이다. 
- `ft_atoi`는 `________`이다.
- `________`에 정의된 코드에서 함수를 호출해온다.
- `write()`는 `________`이다. 이는 `________`에 정의된 함수를 호출하는 것이다.

#### 2. 노련한 개발자인 `daelee`가 만든 프로그램 `get_next_line`은 디스크에 들어있는 200,000 줄짜리 텍스트 파일 `42 norm rules.txt`를 `read()`중이다. 이 실행을 시작한지 0.1초 뒤 `daelee`는 가장 큰 소수를 찾는 프로그램 `biggest prime`을 실행시켰다. `biggest prime` 프로세스가 CPU 제어권을 받아 연산을 실행하는 시점으로 알맞은 것은?

가) `get_next_line`이 `read()`를 호출하기 위해 OS에게 `인터럽트` 라인을 세팅하기 전

나) `디스크 컨트롤러`가 OS에게 입출력 요청을 받은 후

다) `디스크 컨트롤러`가 작업이 완료되었음을 알리는 `인터럽트`를 OS에게 발생시킨 후  
 


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### 1. 보기에서 알맞은 말을 골라 문장을 완성하세요.


`사용자 정의 함수` `시스템 콜 함수` `라이브러리 함수` `ft_print의 주소 공간` `커널의 주소 공간`


- 뛰어난 개발자인 `hylee`가 만든 프로그램 `ft_print`에서 `va_start()`는 `라이브러리 함수`이다. 
- `ft_atoi`는 `사용자 정의 함수`이다.
- `ft_print의 주소 공간`에 정의된 코드에서 함수를 호출해온다.
- `write()`는 `시스템 콜 함수`이다. 이는 다른 프로그램의 공간, 즉 `커널의 주소 공간`에 있는 함수를 호출하는 것이다.

#### 2. 노련한 개발자인 `daelee`가 만든 프로그램 `get_next_line`은 디스크에 들어있는 200,000 줄짜리 텍스트 파일 `42 norm rules.txt`를 `read()`중이다. 이 실행을 시작한지 0.1초 뒤 `daelee`는 가장 큰 소수를 찾는 프로그램 `biggest prime`을 실행시켰다. `biggest prime` 프로세스가 CPU 제어권을 받아 연산을 실행하는 시점으로 알맞은 것은?

가) `get_next_line`이 `read()`를 호출하기 위해 OS에게 `인터럽트` 라인을 세팅하기 전

**나) `디스크 컨트롤러`가 OS에게 입출력 요청을 받은 후**
>디스크 컨트롤러가 입출력 할동안 놀기만 할 수는 없으므로, CPU의 효율적 사용을 위해 CPU 제어권이 다른 프로세스에게 이양된다.

다) `디스크 컨트롤러`가 작업이 완료되었음을 알리는 `인터럽트`를 OS에게 발생시킨 후 


</div>
</details>
<br><br>

### 4-7 :fallen_leaf: 프로세스의 두 가지 실행 상태 	　`kukim`
 
 
프로그램이 시작되어 종료될 때까지 다양한 함수호출을 하며 실행되는데, `( )모드`와 `( )모드`의 실행 상태로 구분 지을 수 있다.

사용자 정의함수나 라이브러리 함수를 호출할 때에는 `(  )모드`에서 실행을 지속하고 시스템 콜을 하는 경우에는 `(  )모드`로 진입해 실행한다.

시스템 콜의 실행이 끝나면 다시 `(  ) 모드`로 복귀해서 시스템콜 이후의 명령들을 계속 실행한다.

프로그램의 실행이 끝날 때에는 `(  ) 모드`로 진입해 프로그램을 종료한다.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
프로그램이 시작되어 종료될 때까지 다양한 함수호출을 하며 실행되는데, `(사용자)모드`와 `(커널)모드`의 실행 상태로 구분 지을 수 있다.

사용자 정의함수나 라이브러리 함수를 호출할 때에는 `(사용자)모드`에서 실행을 지속하고 시스템 콜을 하는 경우에는 `(커널)모드`로 진입해 실행한다.

시스템 콜의 실행이 끝나면 다시 `(사용자) 모드`로 복귀해서 시스템콜 이후의 명령들을 계속 실행한다.

프로그램의 실행이 끝날 때에는 `(커널) 모드`로 진입해 프로그램을 종료한다.
</div>
</details>
<br><br>

