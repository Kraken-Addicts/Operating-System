## 보충3__교착상태

<br>

### 보충3.1 :fallen_leaf:  시스템 모델 `secho`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

<br>

### 보충3.2 :fallen_leaf:  다중 스레드 응용에서의 교착상태　`jehong`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

<br>

### 보충3.3 :fallen_leaf:  교착상태 특성 `taelee`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>



### 보충3.4 :fallen_leaf:  교착상태 처리 방법 `yeosong`

#### 1. 교착 상태 문제를 처리하는 3가지 방법 중 하나인 "문제 무시, 교착 상태가 시스템에서 절대 발생하지 않는 척하기" 는 Windows, Linux가 사용하는 방법이다. `(O/X)` 

#### 2. 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구하여, 스레드가 기다려야 할지 아닐지를 결정하는 방식은 교착상태 `회피avoidence / 예방prevention` 방식이다.

#### 3. 상호배제, 점유하며 대기, 비선점, 순환 대기 4가지의 필요조건 중 적어도 하나가 성립하지 않도록 보장하는 방식은 교착상태 `회피avoidence / 예방prevention` 방식이다.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### 1. 교착 상태 문제를 처리하는 3가지 방법 중 하나인 "문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않는 척한다."는 Windows, Linux가 이 방법을 사용하는 방법이다. `(O)` 
> O. 교착 상태가 드물게 발생하고, 무시가 다른 처리 방법과 비교해 비용이 적게 든다고 판단될 경우 이런 선택을 내릴 수도 있다.

#### 2. 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구하여, 스레드가 기다려야 할지 아닐지를 결정하는 방식은 교착상태 `회피avoidence` 방식이다.

#### 3. 상호배제, 점유하며 대기, 비선점, 순환 대기 4가지의 필요조건 중 적어도 하나가 성립하지 않도록 보장하는 방식은 교착상태 `예방prevention` 방식이다.



</div>
</details>
<br><br>

### 보충3.5 :fallen_leaf:  교착상태 예방 `kukim`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

### 보충3.6 :fallen_leaf:  교착상태 회피 `mihykim`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

