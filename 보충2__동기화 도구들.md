## 보충2__동기화 도구들

<br>

### 보충2.1 :fallen_leaf: 배경　`jehong`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>


### 보충2.2 :fallen_leaf:  임계구역 문제　`taelee`

1. 각 프로세스는 _____ 이라고 부르는 코드 부분을 포함하고 있고 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있다.


2. _______는 프로세스들이 데이터를 협력적으로 공유하기 위하여 자신들의 활동을 동기화할 때 시용할 수 있는 프로토콜을 설계하는 것이다.


3. 임계구역 문제를 해결하기 위해서는 다음 세가지 요구 조건을 충족시켜야 한다.
  - ________: 임계구역에는 동시에 한 프로세스만 접근가능함
  - ________: 유한한 시간 내에 임계구역에 들어갈 프로세스를 정해야함
  - ________: 프로세스가 임계구역을 들어가기 위한 요청 이후 실제 진입까지의 과정이 유한한 시간내에 일어나야함 


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


1. 각 프로세스는 _____ 이라고 부르는 코드 부분을 포함하고 있고 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있다.
**임계구역 (critical section)**

2. _______는 프로세스들이 데이터를 협력적으로 공유하기 위하여 자신들의 활동을 동기화할 때 시용할 수 있는 프로토콜을 설계하는 것이다.
**임계구역 문제**

3. 임계구역 문제를 해결하기 위해서는 다음 세가지 요구 조건을 충족시켜야 한다.
  - ________: 임계구역에는 동시에 한 프로세스만 접근가능함
  - ________: 유한한 시간 내에 임계구역에 들어갈 프로세스를 정해야함
  - ________: 프로세스가 임계구역을 들어가기 위한 요청 이후 실제 진입까지의 과정이 유한한 시간내에 일어나야함 (스케쥴링에서 기아문제같은것이 일어나지 않는것을 말하는 듯) 
**상호 배제(Mutual Exclusion)**
**진행(Progress)**
**한정된 대기(Bounded Waiting)**

### 보충2.3 :fallen_leaf:  Peterson의 해결안 `yeosong`

#### 1. 피터슨 해결법의 단점은 무엇인가요?

#### 2. 피터슨 해결법의 한계는 무엇인가요?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


피터슨의 해결법은 들어가길 원하는지 표시하는 `flag`와 차례인지 표시하는 `turn`을 동시에 써서 임계구역 문제 해결을 위한 3가지 요구조건인 `1.상호배제` `2.진행` `3.유한대기`의 조건을 모두 만족시킵니다.

#### 피터슨 해결법의 단점은 무엇인가요?
> `busy waiting`으로 자원 낭비. <br>
> `busy waiting`이란 대기를 하는 동안 실제로 하는 일은 없는데 CPU를 계속 사용하며 대기하는 것으로, spin lock이라고도 한다.

#### 피터슨 해결법의 한계는 무엇인가요?
> 데이터 무결성 문제를 일으킬 수 있음 / 상호배제 조건 미달 <br>
> 현대적인 아키텍쳐에서는 성능 향상을 위해 작업 순서를 바꿀 수 있기 때문에 <br>
> 다중스레드가 데이터를 공유하는 과정에서 실행할 명령어들의 순서를 바꿔버리면 상호배제 조건이 충족되지 않음. 


</div>
</details>
<br><br>



### 보충2.4 :fallen_leaf:  뮤텍스  `kukim`

1. Mutex lock는 특정 코드 영역의 쓰레드를 실행할 때 한번에 하나 이상의 쓰레드만 실행 가능하도록 하는 방법이다. (O / X)

2. 아래의 코드 결과는 서술하시오.

```c
// exam2.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원, 1증가.
        sleep(1);
    }
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

// compile
// gcc exam2.c -o exam2
```


3. 아래의 코드 결과를 서술하시오

```c
// exam3.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
// 뮤텍스 객체 선언
pthread_mutex_t mutex_lock;
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    
    
 
    pthread_mutex_lock(&mutex_lock);
 
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원
        sleep(1);
    }
 
    pthread_mutex_unlock(&mutex_lock);
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
    // 뮤텍스 객체 초기화, 기본 특성으로 초기화 했음
    pthread_mutex_init(&mutex_lock, NULL);
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

// compile
// gcc exam3.c -o exam3 -lpthread
```

Mutex 코드 참고(문제 다 풀고 들어가세요)
https://bitsoul.tistory.com/172

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


1. Mutex lock는 특정 코드 영역의 쓰레드를 실행할 때 한번에 하나 이상의 쓰레드만 실행 가능하도록 하는 방법이다. (O / X)
  - 정답 : X , 한번에 하나의 쓰레드만 실행 가능하도록 하는 방법이다.

2. 아래의 코드 결과는 서술하시오.

```c
// exam2.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원, 1증가.
        sleep(1);
    }
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

// compile
// gcc exam2.c -o exam2
```
- 정답 : Thread1, 2 모두 g_count 쓰레드 자원을 공유하기 때문에 매번 exam2를 실행할 때 마다 이상한 값이 나온다.


3. 아래의 코드 결과를 서술하시오

```c
// exam3.c

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
// 뮤텍스 객체 선언
pthread_mutex_t mutex_lock;
 
int g_count = 0;  // 쓰레드 공유자원.
 
void *t_function(void *data)
{
    int i;
    char* thread_name = (char*)data;
    
    
 
    pthread_mutex_lock(&mutex_lock);
 
    // critical section
    g_count = 0;   // 쓰레드마다 0부터 시작.
    for (i = 0; i < 3; i++)
    {
        printf("%s COUNT %d\n", thread_name, g_count);
        g_count++;  // 쓰레드 공유자원
        sleep(1);
    }
 
    pthread_mutex_unlock(&mutex_lock);
}
int main()
{
    pthread_t p_thread1, p_thread2;
    int status;
    // 뮤텍스 객체 초기화, 기본 특성으로 초기화 했음
    pthread_mutex_init(&mutex_lock, NULL);
 
    pthread_create(&p_thread1, NULL, t_function, (void *)"Thread1");
    pthread_create(&p_thread2, NULL, t_function, (void *)"Thread2");
 
    pthread_join(p_thread1, (void *)&status);
    pthread_join(p_thread2, (void *)&status);
}

// compile
// gcc exam3.c -o exam3 -lpthread
```
- 정답 : Mutex Lock이 걸려서 Thread1이 먼저 실행된다면 Thread2는 1이 끝날 때 까지 임계영역에 들어가 수 없기 때문에 count 0 1 2를 출력하고 그 다음 Thread2의 count가 0 1 2 를 출력한다. 만약 Thread2가 먼저 실행된다면 앞에 설명한 것과 반대로 출력된다.

Mutex 코드 참고
https://bitsoul.tistory.com/172
</div>
</details>
<br><br>

### 보충2.5 :fallen_leaf:  세마포  `mihykim`

#### 문제1 🏃‍ 세마포 정의
- __[1-1] 다음중 세마포의 정의로 가장 적절한 것은?__
  - a. '세'초가 '마'싯는거 '포'기함
  - b. 순차적으로 리소스에 접근 허용이 가능한 개수를 의미하는 정수 변수
  - c. 동시에 리소스에 접근 허용이 가능한 개수를 의미하는 실수 변수
  - d. 동시에 리소스에 접근 허용이 가능한 개수를 의미하는 정수 변수
- __[1-2] 다음 중 세마포에서 가능한 모든 연산에 해당하는 것은? (단, 초기화 제외)__
  - a. eat(), pray(), love()
  - b. love(), sick(), girl()
  - c. signal(), twice()
  - d. wait(), signal()
  
#### 문제2 🏃‍ P연산 / V연산
```
<보기>
S > 0　　S >= 0　　S < 0　　S <= 0　　S == 0　　S++;　　S--;
```
- __[2-1] 보기에서 아래 내용에 해당되는 적절한 범위를 골라주세요__
  - 새로운 스레드가 임계영역(Critical Section)에 진입할 수 없는 범위 : `　　　　`
  - 새로운 스레드가 임계영역(Critical Section)에 진입할 수 있는 범위 : `　　　　`
  
- __[2-2] 보기에서 💙(a)와 (b)💙에 들어갈 적절한 수식을 골라주세요__
```c
wait(S) {
    while (💙(a)💙)
      ; //busy wait
    S--;
}
// P(S) : S값 검사 (공유자원을 획득하기 위한 과정)

signal(S) {
  💙(b)💙;
}
// V(S) : S값 증가 (공유자원을 다 사용하고 나서 반납하는 과정)
```

#### 문제3 🏃‍ 세마포 종류
- __다음 설명을 읽고 적절한 세마포 종류를 적어주세요(단답식, 1등 +50점)__
  - 0과 1의 값만 가능해서, 쿠키교수님께서 설명해주신 'Mutex락'과 유사하게 동작하는 세마포어 : `ㅇㅇ 세마포어(...... semaphores)`
  - 영역(domain)에 제한이 없어 총 가용한 자원의 개수로 초기화되는 세마포어 : `ㅇㅇㅇ 세마포어(........ semaphorse)`

#### 문제4 🏃‍ 스핀락
```
✨스핀락(Spin Lock)이란?
- 임계구역(Critical Section) 진입이 불가할 때 가능할 때까지 whlie문을 돌면서 재시도하는 방식으로 구현된 락
- OS의 스케줄링 지원을 받지 않기 때문에, 해당 스레드에 대한 문맥교환(Context Switching)이 일어나지 않음
- 만약, 스핀락이 오랜 시간을 소요한다면 바쁜 대기(Busy Waiting) 현상으로 인해 비효율적임
- 만약, 스핀락이 오랜 시간을 소요하지 않는다면 문맥교환(Context Switching)에 따른 오버헤드를 줄일 수 있어서 효율적임
```
- __[4-1] 위 설명을 읽고, 스핀락이 단일 프로세서 시스템에 적합하지 않은 이유를 설명해주세요(+150점)__
  - 이유 : 
- __[4-2] 위 설명을 읽고, 스핀락이 다중 처리기 시스템에서는 종종 사용되는 이유를 설명해주세요(+200점)__
  - 이유 : 

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

#### 문제1 🏃‍ 세마포 정의
- __[1-1] 다음중 세마포의 정의로 가장 적절한 것은?__
  - d. 동시에 리소스에 접근 허용이 가능한 개수를 의미하는 정수 변수
- __[1-2] 다음 중 세마포에서 가능한 모든 연산에 해당하는 것은? (단, 초기화 제외)__
  - d. wait(), signal()
  
#### 문제2 🏃‍ P연산 / V연산
- __[2-2] 보기에서 💙(a)와 (b)💙에 들어갈 적절한 수식을 골라주세요__
  - 새로운 스레드가 임계영역(Critical Section)에 진입할 수 없는 범위 : `S <= 0`
  - 새로운 스레드가 임계영역(Critical Section)에 진입할 수 있는 범위 : `S > 0 `
  
- __[2-2] 보기에서 💙💙💙에 들어갈 적절한 수식을 골라주세요__
```c
wait(S) {
    while (💙S <= 0💙)
      ; //busy wait
    S--;
}
// P(S) : S값 검사 (공유자원을 획득하기 위한 과정)

signal(S) {
  💙S++;💙
}
// V(S) : S값 증가 (공유자원을 다 사용하고 나서 반납하는 과정)
```

#### 문제3 🏃‍ 세마포 종류
- __다음 설명을 읽고 적절한 세마포 종류를 적어주세요(단답식, 1등 +50점)__
  - 0과 1의 값만 가능해서, 쿠키교수님께서 설명해주신 'Mutex락'과 유사하게 동작하는 세마포어 : `이진 세마포어(binary semaphores)`
  - 영역(domain)에 제한이 없어 총 가용한 자원의 개수로 초기화되는 세마포어 : `카운팅 세마포어(counting semaphorse)`

#### 문제4 🏃‍ 스핀락

- __[4-1] 위 설명을 읽고, 스핀락이 단일 프로세서 시스템에 적합하지 않은 이유를 설명해주세요(+150점)__
  - 이유 : 다른 스레드가 Lock을 가지고 있고 그 스레드가 Lock을 풀어주려면 싱글 CPU 시스템에서는 어차피 Context Switching이 일어나야 하기 때문에 스핀락의 장점이 사라지게 됩니다.
- __[4-2] 위 설명을 읽고, 스핀락이 다중 처리기 시스템에서는 종종 사용되는 이유를 설명해주세요(+200점)__
  - 이유 : 하지만 멀티프로세서 시스템에서는 만약 스핀락의 기다리는 시간이 그리 길지 않다면, Busy Waiting을 하는 것이 Context Switching 을 통해 다른 프로세스로 전환되는데 드는 오버헤드보다 작을 것이기 때문에 종종 쓰입니다.
</div>
</details>
<br><br>

### 보충2.6 :fallen_leaf:  모니터  `daelee`

문제 작성

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


답지작성

</div>
</details>
<br><br>

